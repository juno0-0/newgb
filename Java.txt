IDE(Integrated Development Environment)
	통합 개발 환경
	한 회사에서 하나의 프로젝트만 담당하지 않는다.
	여러 프로젝트를 다루기 위해서는 하나의 IDE가 아닌
	여러 버전의 IDE가 필요하기 때문에 무설치 버전으로 설치하는 것이 일반적이다.

JVM(자바 가상 운영체제)
	자바 프로그램
	JVM(운영체제의 종류에 맞게 사용자의 명령을 전송한다)
	OS(하드웨어에 적절한 전기 신호를 흘려주는 역할)
	하드웨어

	머신은 운영체제라고 생각하자
        
JRE
	JVM을 구동시키기 위한 다양한 라이브러리 환경

JDK(Java Development Kit)
	개발 도구상자
	설치시 javac(자바컴파일러)와 java가 자동으로 생성된다.

이클립스 단축키
	alt + shift + n > 아래방향키, 엔터
	프로젝트명 입력 후 엔터
	엔터(폴더가 열림) > 아래방향키 2번
	ctrl + n, Class 선택 후 패키지명과 클래스명 입력 > 엔터

	자동 정렬 : ctrl + shift + f
	자동 import : ctrl + shift + o
	한줄 삭제 : ctrl + d
----------------------------------------------------------------------------------------------------------------------
변수(저장공간)
	어떤 값이 들어올지 자료형으로 알려주어 선언한다.

	1. 같은 값이 반복하여 사용될 때(유지보수가 용이해진다.)
	2. 값에 의미부여를 할 수 있다.
----------------------------------------------------------------------------------------------------------------------
연산자(최단삼쉬관리삼대)
	결합성
		동일한 연산자가 하나의 수식에 여러 개 존재할 때 알맞은 방향으로 결합되어 연산되는 성질
			ex)  a = b + c + d
			         b + c → (b + c) + d → a = (b + c) + d
	우선순위
		다양한 연산자가 하나의 수식에 존재할 때 순서를 매기는 방법
		최우선
		단항
		산술
		쉬프트
		관계
		논리
		삼항
		대입
----------------------------------------------------------------------------------------------------------------------
제어문(if, 삼항연산자, switch, for, while)

조건문
	if문과 삼항연산자의 차이점
		if문은 속도가 상대적으로 느리지만 메모리를 덜 사용한다.(연산을 덜 한다.)
		삼항연산자는 속도가 빠르지만 메모리를 더 사용한다.(보통 메소드의 리턴값에 자주 사용)

반복문
	몇 번 반복할 지 【알 수 있는 경우 for문】 사용
	몇 번 반복할 지 【알 수 없는 경우 while문】 사용
----------------------------------------------------------------------------------------------------------------------
메모리구조
Storage Class(저장 기억 부류)
	Storage = 저장소
	Class = 공통요소들이 모여있는 반

	Stack		Heap		Data
변수	지역,매개				전역, static(정적)
초기화	직접,직접				자동, 자동
생명주기	  }		GC가 해줌	new, 프로그램 종료시
보안성	상				중, 하
※ 보안성은 값이 계속 저장되어 있고 다른데서도 변경이 가능하면 떨어진다.

※ static의 생명주기에서 프로그램 종료는 F11을 눌러서 다시 컴파일 하는 것을 의미한다.

※ 예전에는 전역변수만 존재했다.
	하지만 메모리의 크기도 작았고,
	전역변수는 계속 메모리를 소모하고 프로그램 종료시까지 남아있기 때문에
	지역변수를 만든 것이다.
----------------------------------------------------------------------------------------------------------------------
배열(index)
	int[] arData = {3, 5, 7, 8, 9}
	arData가 전역변수면 Data영역
		지역변수면 Stack영역
	{3, 5, 7, 8, 9}는 Heap영역

	이름이 1개 = 저장공간도 1개 = 값도 1개

	제일 첫번째 방의 주소값을 가지고 있다.
		첫번째 방의 주소만 알고 있으면 모든 값에 접근 가능
		만약 첫번째 방이 아닌 다른 방의 주소를 알고 있으면
		'-'까지 사용해야 함
	
	index가 0부터 시작하는 이유
		배열명이 시작주소를 가지고 있기 때문이다.★★★
		배열명이 배열의 시작 주소를 가지고 있어서
		그 주소부터 배열이 시작하기 때문에 0부터 시작하는 것

	자바에서의 정적배열과 동적배열
		정적배열
			크기가 【고정】 되어 있는 배열
		동적배열
			크기가 【변경】되는 배열
		
		자바에서는 메모리상 정적배열이 존재하지 않는다.
			모든 배열은 동적 메모리인 Heap메모리에 할당되기 때문이다.★★
			예를 들어 int[] arData = new int[3];일 경우
			크기가 고정되어 있지만 메모리는 동적 메모리인 Heap에 올라가기 때문이다.
----------------------------------------------------------------------------------------------------------------------
메소드(주소)
	함수와 메소드의 차이
		함수 : 어떠한 영역에도 갇혀 있지 않다.
		메소드 : 어떠한 영역 내에서 선언 된다.
	
	메소드는 작성된 코드의 주소값을 담고 있는 저장공간이다.★
		변수, 객체, 메소드, 클래스 전부 저장공간인데 어떤 값이 담기느냐에 따라 나뉘는 것
		메소드 내에 소스코드를 작성하면 RAM의 TEXT영역에 저장되고,
		그 주소값을 메소드가 가지고 있는 것
		메소드를 호출하면 메소드로 가서 처리하는 것이 아니라
		메소드가 가지고 있는 주소(RAM의 TEXT영역)로 가서
		소스코드를 실행하고 그 결과값을 메소드가 리턴받아서 메소드를 호출한 곳으로 돌려주는 것

	메소드의 선언 순서
	예) 두 정수의 덧셈
		1. 메소드의 이름을 생각한다.
			addFor2Integers(){ }
		2. 매개변수를 생각한다.
			addFor2Integers(int num1, int num2){ }
		3. 실행할 문장을 작성한다.
			addFor2Integers(int num1, int num2){
				int result = num1 + num2;
			}
		4. 리턴 값을 생각한다.
			addFor2Integers(int num1, int num2){
				int result = num1 + num2;
				return result;
			}
		5. 리턴 타입을 결정한다.
			int addFor2Integers(int num1, int num2){
				int result = num1 + num2;
				return result;
			}

	메소드를 사용하는 목적★★★
		1. 재사용(특정성을 부여해서는 안된다.)
			두 정수를 입력받고 합을 구하는 메소드를 선언할 경우
			public void add(){
				int num1, num2;
				Scanner sc = new Scanner(System.in);
				num1 = sc.nextInt();
				...
			}//이렇게 선언하면 특정성이 생겨서 안된다.
			 //왜냐하면 모든 사용자가 num1, num2를 주는 방법을 아는 것이 아니기 때문이다.

			public void add(int num1, int num2){
				...
			}//이렇게 num1, num2는 알아서 구하게 하고
			 //어디서 호출하든 같은 내용이 실행되도록 만든다.

		2. 소스코드의 간결화
			중복되는 코드를 메소드로 만들어서
			동일한 동작을 할 때 코드 작성이 아닌 메소드 호출로 인하여 1줄로 만드는 것

	메소드에서 리턴
		1. 리턴을 해야할 때
			사용하는 부분에 작업의 결과를 알려주어야 할 때
			ex) 두 정수의 합을 구하는 메소드 선언
		2. 리턴을 할 필요 없을 때
			메소드 내에서 모든 작업이 완료되었을 때
			ex) 두 정수의 합을 println()으로 출력하는 메소드

※ 메소드를 생성할 때 사용할 사람의 입장에서 생각하자.
----------------------------------------------------------------------------------------------------------------------
자바의 구조
프로젝트
	패키지
		클래스(앞글자가 대문자)
			메소드(이름뒤에 ())
				소스코드
----------------------------------------------------------------------------------------------------------------------
클래스(반)
	클래스는 타입이다.
		공통요소(필드)를 매번 새로 선언하지 않고
		하나의 클래스 안에서 한 번 선언하여 가져다 사용한다.
	추상적인 것

객체(인스턴스 변수)
	추상화된 개념을 구체(실체)화 시킨 것
	클래스의 필드에 접근할 수 있는 변수
		변수라는 개념안에 객체가 들어있는 것
		【값】이 담기면 변수
		【주소값】이 담기면 객체
	클래스 안에 있는 필드를 객체(인스턴스 변수)라고도 부른다.
		ex) 자동차의 필드
			바퀴
			창문처럼
			자동차를 실체화시키는 것이기 때문이다.

객체화(인스턴스)
	객체를 만드는 작업
	추상적인 개념을 구체(실체)화 시키는 작업
	Car 	momCar	=	new 	Car();
	클래스	객체		Heap	할당된 필드의 주소값
	
	자동차(클래스)라는 개념을 설명할 때 구체화 시켜서 설명
		ex) 엄마차의 색깔은 말이야?

※ '.' : 하위 연산자, 멤버변수 접근 연산자
	'.'뒤에 나오는 주소로 가라.
	객체명.필드명
		객체명 안에 있는 필드명으로 가라
	객체명.메소드명()
		객체명 안에 있는 메소드명()으로 가라

생성자(Constructor)
	클래스명뒤에 ()

	이름 뒤에 소괄호가 있기 때문에 메소드와 동일한 기능을 가지고 있다.
	하지만 생성자는 리턴이라는 기능을 제공하지 않아서 메소드라고 할 수 없다.
		생성자는 할당된 필드의 주소값을 리턴해야 하는데 다른 것을 리턴하면 안되기 때문에
		리턴 기능을 제공하지 않는 것
	생성자와 메소드를 구분해야 하기 때문에 메소드는 항상 첫 글자가 소문자, 생성자는 대문자

	생성자의 목적★
		1. 해당 클래스 필드를 메모리에 할당한 후 할당된 주소값을 리턴
		2. 초기화의 목적

기본 생성자
	클래스 선언 시 자동으로 기본 생성자가 생성된다.
	만약 사용자가 직접 생성자를 선언한다면
	선언한 생성자가 기본 생성자로 인식 된다.
		기본 생성자가 필요한 경우 직접 만들어줘야 한다.

this
	하나의 클래스로부터 여러 객체가 생성된다.
	각 객체별로 같은 필드를 구성하고 있고,
	특정 객체의 멤버변수에 접근하기 위해서는 해당 객체가 가지고 있는 주소값이 필요하다.
	소스코드 상에서 필드 안에 메소드를 선언할 때 한 번만 선언하고,
	그 안에서 멤버변수를 사용할 때 어떤 객체의 멤버변수인지를 알 수가 없다.
	따라서 객체가 메소드에 접근하면 가지고 있는 주소값을 해당 메소드에게 전달하고,
	전달된 주소값을 this라는 변수가 받는다.
	그러므로 this.멤버변수로 사용해야 정확히 원하는 필드에 접근할 수 있게 된다.
	하지만 매번 this.을 붙이기 번거롭기 때문에
	지역변수(메소드의 매개변수)와 this.멤버변수의 이름이 같지 않다면 생략이 가능하다.

	하나의 응용프로그램에서는 this가 단 하나,
	따라서 단일 프로세스인 자바는 this가 여러개 생길 수 없다.★
----------------------------------------------------------------------------------------------------------------------
null
	null은 아직 어떤 주소값을 할당할 지 모를 때 쓰는 주소 초기값이다.
	선언 후 누적연결 사용시 초기화 방법
		String data = "";
	선언 후 대입 사용시 초기화 방법
		String data = null;
		여기서 누적연결을 하면 결과가 "null연결된데이터"가 나온다.
----------------------------------------------------------------------------------------------------------------------
다형성(Polymorphism) - 메소드에 관련된 성질
	이름이 하나인데 형태가 다양하다.
	JSP에선 거의 쓰지 않고 Spring에서 주로 씀
		(Spring에서 기본 생성자를 통해 데이터를 주고 받기 때문에)
	
	1. 오버로딩(Overloading)
		매개변수의 개수, 순서 혹은 타입이 서로 다르면
		같은 이름의 메소드로 선언이 가능하다.

	2. 오버라이딩(Overriding) - 무시하다, 기각하다
		부모에 있는 메소드가 자식에서 수정이 필요하다면,
		똑같은 이름으로 자식에게 선언해준다.
		그러면 부모 필드에 선언된 메소드가 먼저 메모리에 할당되고,
		그 다음 자식 필드에 재정의된 메소드가 할당된다.
		같은 이름의 저장공간은 선언될 수 없으므로,
		이미 선언된 부모의 메소드 저장공간에 
		자식에서 새롭게 재정의한 코드의 주소값이 들어간다.
			(덮어쓰기 개념)

		ex)
		String data = "안녕"; //부모
		data = "하세요"; //자식
		결과는 "하세요"가 나온다.
		이런 구조가 재정의

super.메소드;
	자식에서 재정의된 소스코드로 바뀌기 전에
	부모의 메소드를 호출하면 효율적으로 재정의를 구현할 수 있게 된다.
		부모에서 선언한 메소드에서 약간의 형태를 변형해야 하는 경우
		자식에서 재정의할 때 필요한 내용만 추가하고
		super.메소드로 부모의 메소드를 실행한다.
	
	ex)
	String data = "안녕"; //부모
	data += "하세요"; //자식
	자식에서 부모의 기능을 그대로 유지한 후 추가한다.
----------------------------------------------------------------------------------------------------------------------
클래스 배열
	같은 타입의 객체가 여러 개 있을 때 객체명도 여러 개이다.
	이름이 여러 개이면 관리하기 어렵기 때문에 객체 배열로 선언하여 사용한다.

	클래스 배열 선언
		1. 클래스명[] 배열명 = new 클래스명[길이];
		2. 클래스명[] 배열명 = {
			new 클래스명(),
			new 클래스명(),
			new 클래스명(),
			...
		}

	클래스 배열 사용
		배열명[i].필드명;
		배열명[i].메소드명();
----------------------------------------------------------------------------------------------------------------------
Casting(강제 형변환)
	모든 자식은 부모 타입이다.★★★★★

	up casting 
		부모 타입에 자식 값을 넣는 형변환
		부모 변수명 = new 자식();
	down casting
		up casting된 객체를 자식 타입으로 형변환
		자식 변수명 = (자식)부모변수명;
			new 부모()를 넣으면 여기엔 자식의 멤버가 없다.

	사용하는 이유
		하나의 부모에서 자식은 여러 개이다.
		모든 자식을 하나로 묶기 위해서는 up casting이 필요하다.
		전달받은 자식 값의 필드를 다시 모두 사용하기 위해서는
		down casting으로 복원한다.

타입 비교(instanceof)
	a instanceof A : a객체가 A타입이면 true, 아니면 false
	ex) "안녕" instanceof String = true
----------------------------------------------------------------------------------------------------------------------
접근권한 제어자(약속, 경고)
	보안이라기에는 너무 취약하다.
	자료형 앞에 작성하여 영역관리를 할 수 있다.

	default : 【다른 패키지】에서 사용할 수 없다.
	public : 【모든 곳】에서 사용할 수 있다.(패키지 안에서 메인 클래스 앞에 작성, 2개는 불가능)
	protectef : 【다른 패키지】에서 사용할 수 없다.【자식은 가능하다.】
	private : 【다른 클래스】에서 사용할 수 없다.

	private이 직접 접근을 막고 getter & setter를 쓰는 이유
		JSP에서는 태그로 변수에 접근하는데
		메소드로만 호출할 수 있기 때문이다.
----------------------------------------------------------------------------------------------------------------------
추상메소드
	{ } 바디가 존재하지 않는다.
	세부적인 내용들이 정의되어 있지 않은 상태이다.

추상클래스(불완전한 클래스)
	추상메소드가 한 개 이상 포함이 된다면, 클래스는 추상 클래스로 선언해야 한다.
	구체적인 내용은 하위 클래스(자식)에서 재정의하여 구현한다.
	자식에서는 반드시 구현해야 하기 때문에 이를 【강제성】이라고 한다.

	추상클래스 선언
		abstract class 추상클래스명{
			abstract 리턴타입 추상메소드명();
		}

		일반 클래스는 【클래스가 추상적】
		추상 클래스는 【필드도 추상적】
		추상 클래스에서도 일반 메소드만 선언할 수 있지만
			그렇게 되면 추상 클래스를 쓰는 이유가 없다.
		
		클래스도 저장공간이다.
----------------------------------------------------------------------------------------------------------------------
인터페이스(틀)
	추상 클래스를 고도화 시킨 문법이다.
	【반드시 추상메소드와 상수만 선언】해야 한다.
	다른 클래스에서 인터페이스를 지정받을 때 implements를 사용한다.
	인터페이스는 여러 개를 지정받을 수 있다.
	지정받은 자식 클래스에서는 인터페이스가 가지고 있는 추상 메소드를
	【반드시 재정의】 해야한다.
			
	jdk1.8부터 인터페이스에서 default 메소드를 선언할 수 있다.({ }가 있는 메소드)
	사실상 다중상속을 지원하게 된 것

	【모호성】이란 이름이 같은 필드를 호출할 때 발생하는 오류
	인터페이스끼리 모호성이 발생하면, 지정받은 클래스에서 재정의를 통해 해결한다.
	부모 클래스와 인터페이스가 모호성이 발생하면, 부모 클래스가 호출된다.
	
	필드는 final static이 생략되어 있다.
	메소드는 abstract가 생략되어 있다.

다중상속
	하나의 자식이 여러 부모를 상속받는 기법
	여러 부모 클래스에 같은 이름의 필드가 있고,
	이를 자식 클래스에서 사용했을 경우 
	어떤 부모의 필드인지 알 수 없기 때문에 문제가 발생한다.(모호성)
	모호성의 문제가 심각하기 때문에 JAVA에서는 다중 상속을 지원하지 않으며,
	해결 방법으로는 인터페이스 기술을 제시하였다.

Adapter	
	클래스가 인터페이스를 바로 받으면 필요 없는 메소드까지 재정의해야 하기 때문에
	중간에 추상클래스를 넣어 추상클래스가 인터페이스를 받아서 강제성을 없애고
	클래스가 추상클래스를 상속받아서 필요한 메소드만 사용한다.
	여기서 추상클래스를 Adapter라고 한다.

	인터페이스도 부모다.
	자식은 부모타입이기 때문에 추상클래스가 인터페이스를 받고
	클래스가 추상클래스를 상속받아도 메소드의 타입은 인터페이스 타입이다.

	Interface -> Abstract Class -> Class
	         강제성	     강제성소멸

익명클래스(Anonymous class)
	Anon class라고도 부름
	이름이 없는 클래스, 일회성 클래스
----------------------------------------------------------------------------------------------------------------------
GUI
	컨테이너 : 컴포넌트를 배치할 수 있는 창
	컴포넌트 : 각 요소(버튼, 라벨, 텍스트필드 등)
	레이아웃 : 컴포넌트 배치방법
	이벤트 : 마우스 혹은 키보드 입력 시 구현해야할 메소드

	모든 이벤트를 구현하고자 할 때에는 인터페이스 구현,
	원하는 이벤트를 골라서 구현할 때에는 이벤트 인터페이스를 지정받은
	추상클래스를 구현
----------------------------------------------------------------------------------------------------------------------
내부클래스
	클래스 안에 클래스를 선언
		메소드 안에서도 클래스를 생성할 수 있다.

	웹개발에서는 잘 쓰지 않고, 안드로이드에서 주로 사용	
----------------------------------------------------------------------------------------------------------------------
[실습]
인터페이스 : Cafe.java(아직 구현되지 않은 3가지 기능)
Starbucks.java(본사)
Road.java(main메소드)

스타벅스 매장은 한 개가 아니라 여러 개이다.
각 매장은 신규 오픈 시 본사에 정보를 등록해야 한다.
등록해야 할 정보는 아래와 같다.
1. 메뉴
2. 가격
3. 판매방식

본사에서는 신규 오픈 한 매장에서 전달한 3가지 정보를 
직접 사용하는 등록 메소드를 구현해 놓는다.
신규 오픈한 매장은 등록 메소드 실행 시 3가지 정보를 구현하게 되고
콘솔창에 구현한 정보를 확인할 수 있다.

1. 강남 매장은 메뉴별 가격이 존재한다.
2. 잠실 매장은 무료 나눔 매장이다.(판매방식과 가격이 필요없다. Adapter를 사용한다.)
------------------------------------------------------------------------------
마커 인터페이스(Marker)
	특정 클래스들을 【그룹화】하기 위하여 사용한다.
	인터페이스도 부모이고, 타입으로 볼 줄 알아야한다.★
------------------------------------------------------------------------------
예외처리
	에러 : 심각한 오류, 개발자가 해결할 수 없는 것
	예외 : 덜 심각한 오류, 개발자가 해결할 수 있는 것
	표현을 할 때는 오류라고 통일한다.

	예외 발생 시 해당 예외 필드가 메모리에 할당되고,
		ex) throw new Exception();
	할당된 필드의 주소값이 예외가 발생된 곳(catch의 매개변수)으로 날아온다.
	이를 잡아주는 문법이 try catch문이다.


	try {
		오류가 날 수 있는 문장
	} catch(예외이름 객체명) {	발생하는 예외는 전부 클래스로 되어 있고, Exception의 자식이다.
		단순히 예외만 잡을꺼면 Exception으로 잡아도 되는데
		이런 상황에는 이렇게 처리하겠다 할 때는 정확한 예외명을 적어준다.
			ex) ArithmeticException이 발생하면 syso("수학적 오류")를 띄울 경우
		 
		객체명.필드명;으로 메소드 사용

		오류 발생 시 실행할 문장을 적는다.

	} catch(예외이름 객체명) {	예외의 종류가 다양할 경우 catch문을 여러개 사용하거나 
				multi try catch문을 사용한다.
	}


	throws(예외 던지기)
		하나의 메소드에서 동일한 예외가 자주 발생될 경우 사용
	
		메소드명() throws Exception명{
			메소드 안에서는 위에 throw한 Exception이 발생하지 않는다.
		}

	
	외부 장치(Driver)를 직접 연결했을 때 사용 후 반드시 장치를 닫아주어야 한다.
	이 때 2가지 방법 중 하나를 사용할 수 있다.
	1. finally 문법을 사용
		파일 입출력이나 JDBC에서만 사용한다.
		
		finally {
			외부 장치 닫기
		}

	2. try statement 문법을 사용
		사용되면 자동으로 close()가 된다.
		
		try(연결 객체) {
			
		} catch() {
		
		}
------------------------------------------------------------------------------
API(Application Programming Interface)
응용프로그램 프로그래밍 인터페이스
	프로그램을 제작할 때, 선배 개발자가 이미 구현한 소스코드를
	그대로 사용할 수 있도록 제공받는 틀이다.
	라이브러리의 집합

	내부 API(기본제공)
		java.lang
			자바 프로그래밍을 위한 가장 기본적인 패키지와 클래스를 포함
		java.util
			데이터를 효율적으로 저장하기 위한 패키지와 클래스를 포함
				대표적으로 컬렉션 프레임워크
		java.io
			키보드, 모니터, 프린터, 파일 등을 제어할 수 있는 패키지와 클래스를 포함
		java.net
			통신을 위한 패키지와 클래스를 포함

	외부 API
		구글맵, 카카오맵, SMS전송, 결제, 인증, 보안, ...
------------------------------------------------------------------------------
어노테이션(@) 주석(파란색 주석)
	/**
		@author : 개발자
		@param : 메소드의 매개변수
		@retrun : 메소드의 리턴값
		@see : 참고할 만한 링크 저장(어느 클래스를 참고하는지?)
		@since : 릴리즈 기록(JDK 버전)
		@throws : 메소드에서 발생할 수 있는 예외
		@version : 클래스 버전(1.0.0) 맨 앞은 버전 뒤에는 업데이트 횟수
	*/

	어노테이션 주석을 코드에 작성을 해도 자동으로 문서화되지 않는다.
	따라서 javadoc.exe 프로그램을 통해 배포해야 한다.

	배포 방법
		배포할 패키지 혹은 클래스 우클릭 → export → Java → Javadoc
		→ 경로 설정(jdk.1.8.xxx → bin → javadoc.exe) → Finish

	프로젝트 폴더 → doc → index.html로 확인할 수 있다.

	[소스코드 배포]
		배포할 패키지 우클릭 → Export → Java → Jar → 저장될 경로 설정 → Finish

	[API import]
		프로젝트 우클릭 → Build Path → Add External JARs → .jar파일 추가 → Apply
------------------------------------------------------------------------------
Object 클래스(최상위 클래스)
	모든 클래스의 조상 클래스
	1. equals() : 주소 비교(==)
		Constant Pool(RAM의 TEXT영역에 있다. 어떤 RAM은 Stack영역에 있다.)
		==을 쓰면 Constant Pool에 해당 값이 있으면 같은 값을 호출할 때 같은 주소를 보내준다.	
		만약 new를 사용해서 주소가 다르지만 값이 같다면 intern()을 사용하여 값을 비교한다.
		intern() : Constant Pool에 해당 문자열과 같은 (String.equals() 리턴값이 true인)
			String 객체가 존재하는 경우 해당 객체의 주소를 리턴하고,
			존재하지 않는 경우 해당 객체를 Pool에 추가하고 해당 객체 주소를 리턴한다.

		예를 들어 String data1 = "ABC"이고, String data2 = "ABC"일 때
		data1 == data2를 하면 Constant Pool에서 값의 주소를 가져와서 비교하여 true가 나온다.
		하지만 String data3 = new String("ABC")이고, String data4 = new String("ABC")일 때
		data3 == data4를 하면 각각의 Heap 메모리에 가서 주소를 가져와서 비교하기 때문에 false가 나온다.
		이럴 경우 값을 비교하고 싶으면
		data3.intern() == data4.intern()을 사용하게 되면
		【Heap 메모리가 아닌 Constant Pool에 있는 주소】를 가져와서 비교하기 때문에 true가 나온다.

	2. hashCode() 
		메모리에 할당된 필드의 주소값을 리턴한다.

	3. toString()
		【객체명】을 출력할 때 항상 toString()이 생략된다.

	핵심은 equals()와 hashCode()를 재정의할 수 있다는 점
	반드시 equals()를 재정의할 때는 hashCode()도 재정의해야 한다.
------------------------------------------------------------------------------
Wrapper Class
	클래스타입 = new 클래스타입();	// 박싱(boxing)
		객체화한 것을 넣어두는 것
	일반타입 = 클래스타입 객체.000Value();	// 언박싱(unboxing)

	JDK1.5버전 이상부터는 오토를 지원한다.
	클래스타입 = 일반타입;	// 오토 박싱(auto boxing)
	일반타입 = 클래스타입;	// 오토 언박싱(auto unboxing)

	Wrapper Class를 사용하는 이유
	1. 일반 타입을 박싱하면 다양한 메소드를 제공받을 수 있다.
	2. 부모의 필드도 사용이 가능하다.
	3. up casting이 가능하다.
------------------------------------------------------------------------------
제네릭(이름이 없는)
	<제네릭명>
	외부에서 전달받을 타입이 어떤 타입일 지 알 수 없을 때
	사용하는 쪽에서 지정하여 사용하도록 하는 기법

	E - Element
	K - Key
	V - Value
	T - Type
	N - Number

	1. Generic class
		클래스 내부에서 사용될 자료형을 지정한다.
		타입을 지정하지 않으면 defalut로 Object가 들어간다.
			이런 경우 쓰는 의미가 없다...
		타입은 반드시 Wrapper class로 써줘야 한다.

	2. Generic method
		메소드 내부에서 사용될 자료형을 지정한다.
		리턴타입 앞에 메소드에서 사용할 타입들을 쓴다.
			내가 제네릭 메소드라는 것을 컴파일러에게 알려주기 위해

	3. Generic interface
		인터페이스 내부에서 사용될 자료형을 지정한 후,
		지정받은 클래스에서 제네릭을 정해준다.
------------------------------------------------------------------------------
알고리즘
	문제의 해결 순서

자료구조
	여러 알고리즘이 모여 구조화가 되어있는 것
	의미없는 데이터가 자료구조를 통과하면 하나의 의미있는 데이터가 되는 것
		값을 변수에 담는 것도 자료구조
			10 : 의미없는 값
			int age = 10 : 자료구조

자료구조는 하나의 틀, 알고리즘은 틀을 채워주는 기능
에를 들어 자판기(자료구조)에 돈(의미없는 데이터)을 넣었을 때
돈을 인식하는 기능(알고리즘1), 버튼을 눌렀을 때 버튼에 맞는 음료수가 나오는 기능(알고리즘2)를 통과하여
음료수(의미있는 데이터)가 나오는 것
------------------------------------------------------------------------------
절차지향 언어(C)
	【자료구조를 만드는 데에 목적】이 있다.
	문제 해결 절차에 맞게 구현되야 하며, 절차가 변할 수는 없다.
		꼭 위에서 아래로가 아니다.

객체지향 언어(JAVA, Python, ...)
	【만들어진 자료구조를 사용하는 데에 목적】이 있다.
	작업 파트별로 클래스를 만든 후 객체로 관리하기 때문에
		여러곳에서 다양하게 사용할 수 있어서 생산성이 좋다.
	단점은 유지보수가 어렵다.
		객체가 어디서 사용되고 있는지 알 수 없기 때문에
------------------------------------------------------------------------------
컬렉션 프레임워크(Collection Framework)
	
	프레임워크와 라이브러리의 차이점
		프레임워크는 전체 로직 흐름을 【스스로】 판단하여 구현
		라이브러리는 【개발자】가 전체 로직 흐름을 판단하여 구현

	많은 데이터를 쉽고 효과적으로 관리할 수 있는
	표준화된 방법을 제공하는 클래스와 인터페이스들의 집합.

	1. List(Collection을 상속)
		구현 클래스
			Vector : 용량관리에 특화되어 있는 자료구조.
				LinkedList나 ArrayList보다 비교적 느림
					동기화 구조로 되어 있어서 쓰레드를 하나씩 처리하기 때문에
				Java 초창기에 나와서 호환성때문에 유지하고 있지만 거의 사용하지 않는다.
				교착상태가 걸릴 수 있으므로 왠만하면 사용하지 않는다.

			LinkedList : 각 저장공간마다 다음 저장공간의 주소를 기억하고 있어서
				   서로 연결이 된 자료구조
					앞뒤 주소로 연결된 것은 이중 LinkedList
		
			ArrayList : 배열을 활용한 자료구조(인덱스로 관리)

			값의 【추가와 삭제】는 노드를 사용하는 【LinkedList】의 성능이 더 좋고
			값의 【검사(검색)】는 인덱스를 사용하는 【ArrayList】를 사용하는 것이 더 좋다.

			배열은 크기를 제한해야 하는 경우 사용하고,
			ArrayList는 몇 개의 데이터가 들어올 지 알 수 없을 때 사용한다.

	2. Set(Collection을 상속)
		집합이다.
		집합은 중복되는 원소를 포함할 수 없다.
		주머니 구조로 데이터를 저장한다.

		구현 클래스
			HashSet
				저장된 값들은 인덱스가 없기 때문에 저장 순서가 고정되어 있지 않다.
				값의 유무 검사, 중복 제거의 목적으로만 사용한다.

				Set의 순서 부여
					iterator() : 반복자(순서가 없는 것에 순서를 부여)

	3. Map
		두 개의 자료구조가 합쳐져 있는 자료구조

		Key와 Value를 한 쌍으로 관리한다.
		Key를 통해서 Value를 가져오는 구조
		Key는 중복이 불가능하지만, Value는 중복이 가능하다.(지하철 물품보관함)
			만약 중복된 Key에 Value를 추가하게 되면 마지막에 넣은 Value값으로 적용된다.
		
		Entry
			Map에서 관리하는 데이터의 한 쌍(Key와 Value)을 Entry타입이라고 부른다.
		Key
			Key에 저장되는 값은 【중복이 안되므로 Set】타입이다.
		Value
			Value에 저장되는 값은 【순서도 있고, 중복이 가능하므로 Collection】 타입이다.

※ 주소값
	C언어에서는 포인터
	JAVA에서는 해시코드

※ 포인터
	1. 주소값
	2. 주소값을 담는 변수

※ C언어는 개발자를 믿기 때문에 시키는건 다함
   JAVA는 개발자를 믿지 않아서 일정 선까지만 함
------------------------------------------------------------------------------
쓰레드(Thread)
	프로그램
		소스코드로 잘 짜여진 틀
		아직 실행되지 않은 상태

	프로세스
		실행중인 프로그램
		운영체제로부터 시스템 자원을 할당받는 작업의 단위
			메소드도 하나의 자원
		개발자는 운영체제랑 소통한다.
			자바 개발자는 JVM이랑 소통한다.
				자바 프로그램
				--------------
				      JVM
				--------------
				   운영체제

	쓰레드
		프로세스의 특정한 수행 경로(프로그램 처리 경로)
			처리하는 순서
		하나의 쓰레드에 여러개의 작업이 있을 수 있고, 하나만 있을 수도 있다.
			싱글과 멀티의 차이는 작업을 혼자 하느냐, 나눠서 하느냐의 차이
		전적으로 JVM에 의해 스케줄링 된다.

		단일 쓰레드(Single Thread, 매표소)
			요청한 순서대로 하나씩 처리한다.
			【직렬적】이다.
			처리경로는 한 개만 존재한다.
			매표소와 같이 앞의 작업이 완료되어야 그 다음 작업이 시작된다.
				따라서 하나의 작업이 오래 걸리면 전체 작업속도가 느려지게 된다.
			하지만 한 개의 작업에서 오류가 발생하면 다른 작업에 영향을 미치지 않기 때문에 안정적이다. 
			하나의 쓰레드 내에서 모든 작업을 순차적으로 진행하기 때문에 메모리를 절약할 수 있다.

		멀티 쓰레드(Multi Thread, 음식점)
			【병렬적】이다.
			여러 개의 처리경로를 가지게 된다.
				한 개의 처리 경로를 나누어 동시 작업이 가능하다.
			하나의 프로세스를 동시에 처리하는 것 처럼 보이지만
				사실은 프로세스를 【매우 짧은 단위로 분할해서 차례로 처리】한다.
					a, b, c가 있으면 a → b → c → a → b → c → ...
			JSP, SpringFramework 웹 서버가 대표적인 멀티 쓰레드 Application이다.
				하지만 모든 웹 서버가 멀티 쓰레드는 아니다.
			장점
				효율성 증가
				처리량 증가
				처리비용 감소
					(1년치 일을 여럿이 처리해서 3개월만에 끝내기 때문에 돈이 덜 나감)
	
			단점
				복잡하고 설계가 어렵다.
				자원을 공유하기 때문에 문제가 발생한다.
					동기화로 해결한다.
				한 개의 쓰레드 문제 발생 시 전부 문제 발생
				교착상태(Dead Lock)
					멀티 쓰레드 중 쓰레드 간 대기 상태가 종료되지 않아서
					모든 쓰레드가 무한정 대기만 하는 비정상적인 상태

					오라클에서는 애플리케이션에 교착상태가 생기면 60초를 기준으로
					교착상태 판단 후 재시작 or 일부를 끊어준다.
		
					해결
						컴퓨터 재부팅
						쓰레드 하나를 지우기
						notifyAll() 사용

			단점이 많음에도 불구하고 사용하는 이유는 장점이 너무 크기 때문이다.

			※ 똑같은 환경에서 사용하면 단일 쓰레드와 멀티 쓰레드의 속도는 똑같다.
	
			※ 작업이 완료되면 메모리에서 해제된다.

			멀티 쓰레드 구현 방법
				1. Thread 클래스 상속
					start()를 바로 사용할 수 있다.

				2. Runnable 인터페이스 지정
					상속을 받아야 하는 경우 사용
					start()를 사용하기 위해 객체를 Thread의 생성자에 전달해주어야 한다.
						Runnable r = new 생성자();
						Thread t = new Thread(r);

	쓰레드풀
		쓰레드 생성에 제한을 두고 작업을 큐 구조로 받아서
		쓰레드가 큐 구조에서 작업을 하나씩 받아서 처리하는 것

	예제
		동물원에 동물 3마리가 있다.
		각 동물은 울음소리가 다르고 2마리의 동물은 동시에 운다.
		나머지 1마리 동물은 2마리 동물이 모두 울고 나서 마지막에 운다.
		클래스는 총 2개를 사용하고 하나의 클래스에는 main메소드가 있다.
		Runnable 인터페이스로 멀티쓰레드를 구현하고 반드시 join()을 사용한다.
		※ 각 동물은 10번씩만 운다.
		※ join()
			먼저 실행하고 싶은 쓰레드에 붙인다. 다른 쓰레드를 대기 상태로 만든다.
			해당 쓰레드가 모두 종료되어야 다른 쓰레드가 실행된다.
			나중에 실행할 Thread보다 위에 있어야 함.
------------------------------------------------------------------------------
인코딩
	사람의 언어를 컴퓨터 언어로 바꾸는 것
		반대는 디코딩
	
	완성형
		EUC-KR, ...
		글자 전체를 바이트로 바꿈
			강낭콩이면 강, 낭, 콩을 바이트로 바꾸는 것

	조합형
		UTF-8, ... (가변형, 메모리를 효율적으로 사용함)
		자음따로 모음따로 바이트로 바꿈
			강낭콩이면 ㄱㅏㅇㄴㅏㅇㅋㅗㅇ을 바이트로 바꾸는 것
------------------------------------------------------------------------------
동기화(Synchronized)
	멀티 쓰레드 환경에서 특정 자원만 단일 쓰레드로 처리해야 하는 경우 사용
	하나의 쓰레드가 자원을 사용하고 있을 때,
		다른 쓰레드가 동시에 같은 필드를 사용하지 못하게 막아주는 문법

	1. 동기화 키워드(메소드)
		메소드 전체가 동기화 된다.
	
	2. 동기화 블럭
		블럭 내부만 동기화 된다.
			메소드 안에 동기화 블럭이 있으면 블럭 내부만 동기화,
			나머지는 동기화되지 않음.

	동기화를 사용하는 이유
		1. 여러 쓰레드가 하나의 자원을 공유했을 때 연산 및 다양한 문제가 발생할 수 있다.
			이 때에는 동기화를 사용하여 쓰레드가 하나씩 접근하도록 막아준다.

		2. 각 쓰레드를 제어하기 위해서
			스킬을 사용하면 스킬은 비활성화되고, 쿨타임이 활성화
			쿨타임이 끝나면 비활성화, 스킬이 활성화

	※ javascript는 동기식(단일 쓰레드)
	   Ajax는 비동기식(멀티 쓰레드)
------------------------------------------------------------------------------
파일 입출력
	Writer(출력)
	Reader(입력)

	File : 경로를 전달해주면 해당 경로의 파일의 정보를 담을 수 있다.
		1. 파일 존재 여부
		2. 해당 경로의 파일삭제
		
	Writer
		- BufferedWriter : 문서(텍스트, 엑셀, ...)
			           문서만 쓸 경우 얘가 효율이 더 좋다.
		- OutputStreamWriter : 파일(이미지, 동영상, ...)

		- FileWriter : 쓰기위한 목적으로 해당 경로의 파일을 열어준다.
				만약 해당 【경로에 파일이 없다면 새롭게 만든 후 가져온다.】
				FileWriter("경로", 추가여부);
					추가여부는 default로 false이며,
					파일 내용을 전부 지운 후 열어준다.
					추가여부를 true로 바꾸면
					기존 내용을 유지하고 마지막에 새로운 내용이 추가된다.

	Reader
		BufferedReader : Writer와 동일하게 문서
		InputStreamReader : Writer와 동일하게 파일

		- FileReader : 읽기위한 목적으로 해당 경로의 파일을 열어준다.
				만약 해당 【경로에 파일이 없다면 예외가 발생】한다.

		반드시 이런 구조로 사용한다.
			Buffered Reader br = null;
			String line = null;
			try {
				br = new BufferedReader(new FileReader("경로"));
				while((line = br.readLine()) != null) {
					line = br.readLine();
					if(line == null) {
						break;
					}
					System.out.println(line);
				}
			} catch (FileNotFoundException e) {
				System.out.println("예외 발생 시 메시지");
			} finally {
				try {
					if(br != null) {br.close();}
				} catch (IOException e) {
					//파일이 닫히지도 않는 경우
					throw new RuntimeException(e.getMessage());
				}
			}

		※ 개행은 객체명.newLine() or \n or \r\n
			운영체제별로 줄바꿈 문자가 다르다.
				자바의 경우 JVM이 운영체제에 맞는 줄바꿈 문자로 바꿔준다.
			하지만 가끔 \n이 파일 Reader에서 운영체제에 따라 인식이 되지 않을 수도 있다.
				그럴 경우 \r\n을 해야한다.

	Buffer(임시 저장 공간)
		.java파일에서 .txt파일에 문자열을 작성할 때
		하나씩 전송하다 보면 효율이 떨어진다.
		따라서 전송할 데이터들을 Buffer라는 저장공간에 한 번에 모은 후 flush()를 통해 비워준다.(일괄처리)
		파일입출력에서는 flush()만 사용하지 않고 열린 파일을 닫아주는 close()를 사용한다.
		사용 후 반드시 close()를 통해 flush()를 해주어야 작성한 내용이 파일에 적용된다.
		flush() : Buffer는 가득차면 한번에 비워주는데 가득차지 않아도 비워주는 메소드

		일괄처리를 하기 위해 사용한다.

		※ 한 번 close()를 한 객체는 new를 해도 열리지 않는다.

	※ RuntimeException을 상속받은 Exception들은 실행 시 오류가 나고, 컴파일 시에는 오류가 나지 않아서
		예외 처리가 강제적이지 않다.
	   하지만 Exception을 바로 상속받은 예외들은 어떠한 특정 로직에 의해서 컴파일 시 오류가 발생하기 때문에
		반드시 예외처리를 해주어야 한다.

	※ Files.readAllBytes(Paths.get("경로"));
		경로에 있는 모든 데이터를 바이트 배열로 변환해서 가져옴

	※ str.charAt(line.length() -1);
		-1을 하지 않으면 ArrayIndexOutOfBoundsException 발생

	※ split("구분자");
		문자열을 split의 구분자를 기준으로 잘라서 String[]으로 리턴

	※ substring(index);
		문자열에서 index번째부터 정보를 가져온다.
		ABCDEFGHIJK가 있을 때 index에 3을 주면 DEFGHIJK가 출력

	※ 메소드에 리턴값이 있으면 메소드()를 값으로 볼 줄 알아야 한다.★★★★★
		split("\t")[0]과
		String[] str = 문자열.split("\t");
		str[0];은 같다.
------------------------------------------------------------------------------
소프트웨어 디자인 설계 패턴
MVC(패턴 중 한 종류)
	Model
		Controller에서 사용하는 비어있는 껍데기
		외부저장소 조회 결과를 담을 수 있는 틀을 선언해 놓은 클래스를 의미한다.
		이러한 클래스를 담아놓은 패키지명은 VO 또는 DTO로 작성한다
			VO(Value Object) : 결과값을 담고 있는 객체
			DTO(Data Transfer Object) : 결과값을 가지고 여기 저기 필요한 쪽으로 전송되는 객체
			둘 중 편한걸 쓴다.

	View
		사용자가 볼 화면을 구성하는 영역
		Controller를 통해서 적절하게 메소드를 호출하고 그 결과를 화면 구성에 맞게 뿌려준다.
			View에서 이벤트가 발생하면 Controller가 호출되는 것
		
	Controller
		외부 저장소에 접근할 수 있는 기능들을 구현한다.
		각 기능들은 메소드로 설계하고 결과가 있다면 Model 객체에 담은 후 리턴해준다.
		Controller를 담아놓은 패키지명은 DAO로 작성한다.
			DAO(Data Access Object) : 데이터에 접근하는 객체

	※ 어플리케이션 개발 시 MVC 모델을 반드시 사용할 필요는 없다.
		웹페이지의 페이지수가 많거나 업데이트를 지속적으로 해야할 경우 사용

		model1(소규모, 중규모)
			Model은 따로 있지만, View와 Controller가 같이 있다.
			model2에 비해서 【설계가 쉽지만】
			Controller와 View가 섞여 있기 때문에 model2에 비해서 【유지보수가 어렵다.】

		model2(대규모)
			【설계가 복잡하고 어렵다.】
			하지만 model1에 비해서 【유지보수 및 분업이 쉽다.】
			대규모 혹은 장기계획을 갖는 프로젝트에 사용되는 설계 패턴이다.

		※ 무조건 1개의 파일은 1명만 건든다.★★★★★
------------------------------------------------------------------------------
암호와와 복호화
	암호화 원리
		비밀번호가 abcd면 아스키코드가 97~100이고
		이 아스키코드에 3을 더하면 defg라는 다른 값이 되는 것
		복호화는 암호화의 반대, -3을 해준다.

	private final static int KEY = 3;
	
	암호화
	public String encrypt(String pw) {
		String en_pw = "";
		for (int i = 0; i < pw.length(); i++) {
			en_pw += (char)(pw.charAt(i) * KEY);
		}
		return en_pw;
	}

	복호화
	public String decrypt(String en_pw) {
		String de_pw = "";
		for (int i = 0; i < en_pw.length(); i++) {
			de_pw += (char)(en_pw.charAt(i) / KEY);
		}
		return de_pw;
	}
------------------------------------------------------------------------------