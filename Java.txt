IDE(eclipse photon)
	한 회사에서 하나의 프로젝트만 담당하지 않는다.
	여러 프로젝트를 다루기 위해서는 하나의 IDE가 아닌
	여러 버전의 IDE가 필요하기 때문에 무설치 버전으로 설치하는 것이 일반적이다.

JVM(자바 가상 운영체제)
	자바 프로그램
	JVM(운영체제의 종류에 맞게 사용자의 명령을 전송한다)
	OS(하드웨어에 적절한 전기 신호를 흘려주는 역할)
	하드웨어

	머신은 운영체제라고 생각하자
        
JRE
	JVM을 구동시키기 위한 다양한 라이브러리 환경

JDK(javac, java)
	개발 도구상자
	설치시 javac(자바컴파일러)와 java가 자동으로 생성된다.

이클립스 단축키
	alt + shift + n > 아래방향키, 엔터
	프로젝트명 입력 후 엔터
	엔터(폴더가 열림) > 아래방향키 2번
	ctrl + n, Class 선택 후 패키지명과 클래스명 입력 > 엔터

	자동 정렬 : ctrl + shift + f
	자동 import : ctrl + shift + o
	한줄 삭제 : ctrl + d
----------------------------------------------------------------------------------------------------------------------
변수(저장공간)
	어떤 값이 들어올지 자료형으로 알려주어 선언한다.

	1. 같은 값이 반복하여 사용될 때(유지보수가 용이해진다.)
	2. 값에 의미부여를 할 수 있다.
----------------------------------------------------------------------------------------------------------------------
연산자(최단삼쉬관리삼대)
	결합성
		동일한 연산자가 하나의 수식에 여러 개 존재할 때 알맞은 방향으로 결합되어 연산되는 성질
			ex)  a = b + c + d
			         b + c → (b + c) + d → a = (b + c) + d
	우선순위
		다양한 연산자가 하나의 수식에 존재할 때 순서를 매기는 방법
		최우선
		단항
		산술
		쉬프트
		관계
		논리
		삼항
		대입
----------------------------------------------------------------------------------------------------------------------
제어문(if, 삼항연산자, switch, for, while)

조건문
	if문과 삼항연산자의 차이점
		if문은 속도가 상대적으로 느리지만 메모리를 덜 사용한다.(연산을 덜 한다.)
		삼항연산자는 속도가 빠르지만 메모리를 더 사용한다.(보통 메소드의 리턴값에 자주 사용)

반복문
	몇 번 반복할 지 【알 수 있는 경우 for문】 사용
	몇 번 반복할 지 【알 수 없는 경우 while문】 사용
----------------------------------------------------------------------------------------------------------------------
메모리구조
Storage Class(저장 기억 부류)
	Storage = 저장소
	Class = 공통요소들이 모여있는 반

	Stack		Heap		Data
변수	지역,매개				전역, static(정적)
초기화	직접,직접				자동, 자동
생명주기	  {		GC가 해줌	new, 프로그램 종료시
보안성	상				중, 하
※ 보안성은 값이 계속 저장되어 있고 다른데서도 변경이 가능하면 떨어진다.
※ 예전에는 전역변수만 존재했다.
	하지만 메모리의 크기도 작았고,
	전역변수는 계속 메모리를 소모하고 프로그램 종료시까지 남아있기 때문에
	지역변수를 만든 것이다.
----------------------------------------------------------------------------------------------------------------------
배열(index)
	int[] arData = {3, 5, 7, 8, 9}
	arData가 전역변수면 Data영역
		지역변수면 Stack영역
	{3, 5, 7, 8, 9}는 Heap영역

	이름이 1개 = 저장공간도 1개 = 값도 1개

	제일 첫번째 방의 주소값을 가지고 있다.
		첫번째 방의 주소만 알고 있으면 모든 값에 접근 가능
		만약 첫번째 방이 아닌 다른 방의 주소를 알고 있으면
		'-'까지 사용해야 함
	
	index가 0부터 시작하는 이유
		배열명이 시작주소를 가지고 있기 때문이다.★★★
		배열명이 배열의 시작 주소를 가지고 있어서
		그 주소부터 배열이 시작하기 때문에 0부터 시작하는 것

	자바에서의 정적배열과 동적배열
		정적배열
			크기가 【고정】 되어 있는 배열
		동적배열
			크기가 【변경】되는 배열
		
		자바에서는 메모리상 정적배열이 존재하지 않는다.
			모든 배열은 동적 메모리인 Heap메모리에 할당되기 때문이다.★★
			예를 들어 int[] arData = new int[3];일 경우
			크기가 고정되어 있지만 메모리는 동적 메모리인 Heap에 올라가기 때문이다.
----------------------------------------------------------------------------------------------------------------------
메소드(주소)
	함수와 메소드의 차이
		함수 : 어떠한 영역에도 갇혀 있지 않다.
		메소드 : 어떠한 영역 내에서 선언 된다.
	
	메소드는 작성된 코드의 주소값을 담고 있는 저장공간이다.★
		변수, 객체, 메소드, 클래스 전부 저장공간인데 어떤 값이 담기느냐에 따라 나뉘는 것
		메소드 내에 소스코드를 작성하면 RAM의 TEXT영역에 저장되고,
		그 주소값을 메소드가 가지고 있는 것
		메소드를 호출하면 메소드로 가서 처리하는 것이 아니라
		메소드가 가지고 있는 주소(RAM의 TEXT영역)로 가서
		소스코드를 실행하고 그 결과값을 메소드가 리턴받아서 메소드를 호출한 곳으로 돌려주는 것

	메소드의 선언 순서
	예) 두 정수의 덧셈
		1. 메소드의 이름을 생각한다.
			addFor2Integers(){ }
		2. 매개변수를 생각한다.
			addFor2Integers(int num1, int num2){ }
		3. 실행할 문장을 작성한다.
			addFor2Integers(int num1, int num2){
				int result = num1 + num2;
			}
		4. 리턴 값을 생각한다.
			addFor2Integers(int num1, int num2){
				int result = num1 + num2;
				return result;
			}
		5. 리턴 타입을 결정한다.
			int addFor2Integers(int num1, int num2){
				int result = num1 + num2;
				return result;
			}

	메소드를 사용하는 목적★★★
		1. 재사용(특정성을 부여해서는 안된다.)
			두 정수를 입력받고 합을 구하는 메소드를 선언할 경우
			public void add(){
				int num1, num2;
				Scanner sc = new Scanner(System.in);
				num1 = sc.nextInt();
				...
			}//이렇게 선언하면 특정성이 생겨서 안된다.
			 //왜냐하면 모든 사용자가 num1, num2를 주는 방법을 모르기 때문이다.

			public void add(int num1, int num2){
				...
			}//이렇게 num1, num2는 알아서 구하게 하고
			 //어디서 호출하든 같은 내용이 실행되도록 만든다.

		2. 소스코드의 간결화
			중복되는 코드를 메소드로 만들어서
			동일한 동작을 할 때 코드 작성이 아닌 메소드 호출로 인하여 1줄로 만드는 것

	메소드에서 리턴
		1. 리턴을 해야할 때
			사용하는 부분에 작업의 결과를 알려주어야 할 때
			ex) 두 정수의 합을 구하는 메소드 선언
		2. 리턴을 할 필요 없을 때
			메소드 내에서 모든 작업이 완료되었을 때
			ex) 두 정수의 합을 println()으로 출력하는 메소드

※ 메소드를 생성할 때 사용할 사람의 입장에서 생각하자.
----------------------------------------------------------------------------------------------------------------------
자바의 구조
프로젝트
	패키지
		클래스(앞글자가 대문자)
			메소드(이름뒤에 ())
				소스코드
----------------------------------------------------------------------------------------------------------------------
클래스(반)
	클래스는 타입이다.
		공통요소(필드)를 매번 새로 선언하지 않고
		하나의 클래스 안에서 한 번 선언하여 가져다 사용한다.
	추상적인 것

객체(인스턴스 변수)
	추상화된 개념을 구체(실체)화 시킨 것
	클래스의 필드에 접근할 수 있는 변수
		변수라는 개념안에 객체가 들어있는 것
		【값】이 담기면 변수
		【주소값】이 담기면 객체
	클래스 안에 있는 필드를 객체(인스턴스 변수)라고도 부른다.
		ex) 자동차의 필드
			바퀴
			창문처럼
			자동차를 실체화시키는 것이기 때문이다.

객체화(인스턴스)
	객체를 만드는 작업
	추상적인 개념을 구체(실체)화 시키는 작업
	Car 	momCar	=	new 	Car();
	클래스	객체		Heap	할당된 필드의 주소값
	
	자동차(클래스)라는 개념을 설명할 때 구체화 시켜서 설명
		ex) 엄마차의 색깔은 말이야?

※ '.' : 하위 연산자, 멤버변수 접근 연산자
	'.'뒤에 나오는 주소로 가라.
	객체명.필드명
		객체명 안에 있는 필드명으로 가라
	객체명.메소드명()
		객체명 안에 있는 메소드명()으로 가라

생성자(Constructor)
	클래스명뒤에 ()

	이름 뒤에 소괄호가 있기 때문에 메소드와 동일한 기능을 가지고 있다.
	하지만 생성자는 리턴이라는 기능을 제공하지 않아서 메소드라고 할 수 없다.
		생성자는 할당된 필드의 주소값을 리턴해야 하는데 다른 것을 리턴하면 안되기 때문에
		리턴 기능을 제공하지 않는 것
	생성자와 메소드를 구분해야 하기 때문에 메소드는 항상 첫 글자가 소문자, 생성자는 대문자

	생성자의 목적★
		1. 해당 클래스 필드를 메모리에 할당한 후 할당된 주소값을 리턴
		2. 초기화의 목적

기본 생성자
	클래스 선언 시 자동으로 기본 생성자가 생성된다.
	만약 사용자가 직접 생성자를 선언한다면
	선언한 생성자가 기본 생성자로 인식 된다.
		기본 생성자가 필요한 경우 직접 만들어줘야 한다.

this
	하나의 클래스로부터 여러 객체가 생성된다.
	각 객체별로 같은 필드를 구성하고 있고,
	특정 객체의 멤버변수에 접근하기 위해서는 해당 객체가 가지고 있는 주소값이 필요하다.
	소스코드 상에서 필드 안에 메소드를 선언할 때 한 번만 선언하고,
	그 안에서 멤버변수를 사용할 때 어떤 객체의 멤버변수인지를 알 수가 없다.
	따라서 객체가 메소드에 접근하면 가지고 있는 주소값을 해당 메소드에게 전달하고,
	전달된 주소값을 this라는 변수가 받는다.
	그러므로 this.멤버변수로 사용해야 정확히 원하는 필드에 접근할 수 있게 된다.
	하지만 매번 this.을 붙이기 번거롭기 때문에
	지역변수(메소드의 매개변수)와 this.멤버변수의 이름이 같지 않다면 생략이 가능하다.

	하나의 응용프로그램에서는 this가 단 하나,
	따라서 단일 프로세스인 자바는 this가 여러개 생길 수 없다.
----------------------------------------------------------------------------------------------------------------------
null
	null은 아직 어떤 주소값을 할당할 지 모를 때 쓰는 주소 초기값이다.
	선언 후 누적연결 사용시 초기화 방법
		String data = "";
	선언 후 대입 사용시 초기화 방법
		String data = null;
		여기서 누적연결을 하면 결과가 "null연결된데이터"가 나온다.
----------------------------------------------------------------------------------------------------------------------
다형성(Polymorphism) - 메소드에 관련된 성질
	이름이 하나인데 형태가 다양하다.
	JSP에선 거의 쓰지 않고 Spring에서 주로 씀
		(Spring에서 기본 생성자를 통해 데이터를 주고 받기 때문에)
	
	1. 오버로딩(Overloading)
		매개변수의 개수, 순서 혹은 타입이 서로 다르면
		같은 이름의 메소드로 선언이 가능하다.

	2. 오버라이딩(Overriding) - 무시하다, 기각하다
		부모에 있는 메소드가 자식에서 수정이 필요하다면,
		똑같은 이름으로 자식에게 선언해준다.
		그러면 부모 필드에 선언된 메소드가 먼저 메모리에 할당되고,
		그 다음 자식 필드에 재정의된 메소드가 할당된다.
		같은 이름의 저장공간은 선언될 수 없으므로,
		이미 선언된 부모의 메소드 저장공간에 
		자식에서 새롭게 재정의한 코드의 주소값이 들어간다.
			(덮어쓰기 개념)

		ex)
		String data = "안녕"; //부모
		data = "하세요"; //자식
		결과는 "하세요"가 나온다.
		이런 구조가 재정의

super.메소드;
	자식에서 재정의된 소스코드로 바뀌기 전에
	부모의 메소드를 호출하면 효율적으로 재정의를 구현할 수 있게 된다.
		부모에서 선언한 메소드에서 약간의 형태를 변형해야 하는 경우
		자식에서 재정의할 때 필요한 내용만 추가하고
		super.메소드로 부모의 메소드를 실행한다.
	
	ex)
	String data = "안녕"; //부모
	data += "하세요"; //자식
	자식에서 부모의 기능을 그대로 유지한 후 추가한다.
----------------------------------------------------------------------------------------------------------------------
클래스 배열
	같은 타입의 객체가 여러 개 있을 때 객체명도 여러 개이다.
	이름이 여러 개이면 관리하기 어렵기 때문에 객체 배열로 선언하여 사용한다.

	클래스 배열 선언
		1. 클래스명[] 배열명 = new 클래스명[길이];
		2. 클래스명[] 배열명 = {
			new 클래스명(),
			new 클래스명(),
			new 클래스명(),
			...
		}

	클래스 배열 사용
		배열명[i].필드명;
		배열명[i].메소드명();
----------------------------------------------------------------------------------------------------------------------
Casting(강제 형변환)
	모든 자식은 부모 타입이다.★★★★★

	up casting 
		부모 타입에 자식 값을 넣는 형변환
		부모 변수명 = new 자식();
	down casting
		up casting된 객체를 자식 타입으로 형변환
		자식 변수명 = (자식)부모변수명;

	사용하는 이유
		하나의 부모에서 자식은 여러 개이다.
		모든 자식을 하나로 묶기 위해서는 up casting이 필요하다.
		전달받은 자식 값의 필드를 다시 모두 사용하기 위해서는
		down casting으로 복원한다.

타입 비교(instanceof)
	a instanceof A : a객체가 A타입이면 true, 아니면 false
	ex) "안녕" instanceof String = true
----------------------------------------------------------------------------------------------------------------------
접근권한 제어자(약속, 경고)
	보안이라기에는 너무 취약하다.
	자료형 앞에 작성하여 영역관리를 할 수 있다.

	default : 【다른 패키지】에서 사용할 수 없다.
	public : 【모든 곳】에서 사용할 수 있다.(패키지 안에서 메인 클래스 앞에 작성, 2개는 불가능)
	protectef : 【다른 패키지】에서 사용할 수 없다.【자식은 가능하다.】
	private : 【다른 클래스】에서 사용할 수 없다.

	private이 직접 접근을 막고 getter & setter를 쓰는 이유
		JSP에서는 태그로 변수에 접근하는데
		메소드로만 호출할 수 있기 때문이다.
----------------------------------------------------------------------------------------------------------------------
추상메소드
	{ } 바디가 존재하지 않는다.
	세부적인 내용들이 정의되어 있지 않은 상태이다.

추상클래스(불완전한 클래스)
	추상메소드가 한 개 이상 포함이 된다면, 클래스는 추상 클래스로 선언해야 한다.
	구체적인 내용은 하위 클래스(자식)에서 재정의하여 구현한다.
	자식에서는 반드시 구현해야 하기 때문에 이를 【강제성】이라고 한다.

	추상클래스 선언
		abstract class 추상클래스명{
			abstract 리턴타입 추상메소드명();
		}

		일반 클래스는 【클래스가 추상적】
		추상 클래스는 【필드도 추상적】
		추상 클래스에서도 일반 메소드만 선언할 수 있지만
			그렇게 되면 추상 클래스를 쓰는 이유가 없다.
		
		클래스도 저장공간이다.
----------------------------------------------------------------------------------------------------------------------
인터페이스(틀)
	추상 클래스를 고도화 시킨 문법이다.
	【반드시 추상메소드와 상수만 선언】해야 한다.
	다른 클래스에서 인터페이스를 지정받을 때 implements를 사용한다.
	인터페이스는 여러 개를 지정받을 수 있다.
	지정받은 자식 클래스에서는 인터페이스가 가지고 있는 추상 메소드를
	【반드시 재정의】 해야한다.
			
	jdk1.8부터 인터페이스에서 default 메소드를 선언할 수 있다.({ }가 있는 메소드)
	사실상 다중상속을 지원하게 된 것

	【모호성】이란 이름이 같은 필드를 호출할 때 발생하는 오류
	인터페이스끼리 모호성이 발생하면, 지정받은 클래스에서 재정의를 통해 해결한다.
	부모 클래스와 인터페이스가 모호성이 발생하면, 부모 클래스가 호출된다.
	
	필드는 final static이 생략되어 있다.
	메소드는 abstract가 생략되어 있다.

다중상속
	하나의 자식이 여러 부모를 상속받는 기법
	여러 부모 클래스에 같은 이름의 필드가 있고,
	이를 자식 클래스에서 사용했을 경우 
	어떤 부모의 필드인지 알 수 없기 때문에 문제가 발생한다.(모호성)
	모호성의 문제가 심각하기 때문에 JAVA에서는 다중 상속을 지원하지 않으며,
	해결 방법으로는 인터페이스 기술을 제시하였다.

Adapter	
	클래스가 인터페이스를 바로 받으면 필요 없는 메소드까지 재정의해야 하기 때문에
	중간에 추상클래스를 넣어 추상클래스가 인터페이스를 받아서 강제성을 없애고
	클래스가 추상클래스를 상속받아서 필요한 메소드만 사용한다.
	여기서 추상클래스를 Adapter라고 한다.

	인터페이스도 부모다.
	자식은 부모타입이기 때문에 추상클래스가 인터페이스를 받고
	클래스가 추상클래스를 상속받아도 메소드의 타입은 인터페이스 타입이다.

	Interface -> Abstract Class -> Class
	         강제성	     강제성소멸

익명클래스(Anonymous class)
	Anon class라고도 부름
	이름이 없는 클래스, 일회성 클래스
----------------------------------------------------------------------------------------------------------------------
GUI
	컨테이너 : 컴포넌트를 배치할 수 있는 창
	컴포넌트 : 각 요소(버튼, 라벨, 텍스트필드 등)
	레이아웃 : 컴포넌트 배치방법
	이벤트 : 마우스 혹은 키보드 입력 시 구현해야할 메소드

	모든 이벤트를 구현하고자 할 때에는 인터페이스 구현,
	원하는 이벤트를 골라서 구현할 때에는 이벤트 인터페이스를 지정받은
	추상클래스를 구현
----------------------------------------------------------------------------------------------------------------------
	
		



	