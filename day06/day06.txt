쓰레드(Thread)
	프로그램
		소스코드로 잘 짜여진 틀
		(실행이 아직 되지 않은 상태)
	프로세스
		실행된 프로그램.
		운영체제로부터 시스템 자원을 할당받는 작업의 단위
			자원 : 메소드 안에 있는 것도 하나의 자원
		개발자는 운영체제(OS)랑 소통한다.
			자바에서는 운영체제 대신 JVM과 소통하여 시스템 자원을 할당받는다.

	쓰레드
		프로세스의 특정한 수행 경로
			add메소드가 있을 때 +를 누르면 메소드가 실행 > 이 경로가 쓰레드
		프로그램 처리 경로
			처리하는 순서
			하나의 쓰레드에 여러개의 작업이 있을 수 있고, 하나만 있을 수도 있다.
		전적으로 JVM에 의해 스케줄링 된다.

	단일 쓰레드(매표소)
		요청한 순서대로 하나씩 처리함
			(순서대로 하나씩)
		직렬적이다. 처리경로는 한 개만 존재한다.
		매표소와 같이 앞의 작업이 완료되어야 그 다음 작업이 시작된다.
		따라서 하나의 작업이 오래 걸리면 전체 작업속도가 느려지게 된다.
		하지만 한 개의 작업에서 오류가 발생하면 다른 작업에 영향을 미치지 않기 때문에
		안정적이고, 하나의 쓰레드 내에서 모든 작업을 순차적으로 진행하기 때문에
		메모리를 절약할 수 있다.

	멀티 쓰레드(음식점)
		a, b, c라는 작업이 있을 때 세 가지 작업이 매우 짧은 단위로 【번갈아가며】 진행되는 것
		병렬적이다. 여러 개의 처리경로를 가지게 되며,
		한 개의 처리 경로를 나누어 동시 작업이 가능하다.
		하나의 프로세스를 동시에 처리하는 것 처럼 보이지만
		사실은 매우 짧은 단위로 분할해서 차례로 처리한다.		
		JSP, SpringFramework 웹 서버가 대표적인 멀티 쓰레드 Application이다.
			모든 웹 서버가 멀티 쓰레드는 아니다.
		장점
			효율성 증가
			처리량 증가
			처리비용 감소
				일을 빨리 끝내서

		단점
			복잡하고 설계가 어려움
			자원 공유 문제(동기화)
			한 개의 쓰레드 문제 발생 시 전부 문제 발생
			교착상태(Dead Lock)
				멀티 쓰레드 중 쓰레드 간 대기 상태가 종료되지 않아서
				모든 쓰레드가 무한정 대기만 하는 비정상적인 상태

				오라클에서는 애플리케이션에 교착상태가 생기면 60초를 기준으로
				교착상태 판단 후 재시작 혹은 일부를 끊어준다.

				컴퓨터 껐다 키거나, 쓰레드 하나를 지운다.
				혹은 notifyAll()을 사용한다.

		단점이 많음에도 불구하고 사용하는 이유는 장점이 너무 크기 때문이다.

	※ 똑같은 환경에서 사용하면 단일 쓰레드와 멀티 쓰레드의 속도는 똑같다.

	※ 작업이 완료되면 메모리에서 해제된다.

	멀티 쓰레드 구현 방법
		Thread 클래스 상속
			start()를 바로 사용할 수 있다.

		Runnable 인터페이스 지정
			상속을 받아야 하는 경우 사용
			start()를 사용하기 위해 객체를 Thread의 생성자에 전달해주어야 한다.
				Runnable r = new 생성자();
				Thread thread = new Thread(r);

	쓰레드풀
		스레드 생성에 제한을 두고 작업을 큐 구조로 받아서 
		쓰레드가 큐 구조에서 하나씩 받아서 처리하는 것(개념만 알아두기)

	예제
		동물원에 동물 3마리가 있다.
		각 동물은 울음소리가 다르고 2마리의 동물은 동시에 운다.
		나머지 1마리 동물은 2마리 동물이 모두 울고 나서 마지막에 운다.
		클래스는 총 2개를 사용하고 하나의 클래스에는 main메소드가 있다.
		Runnable 인터페이스로 멀티쓰레드를 구현하고 반드시 join()을 사용한다.
		※ 각 동물은 10번씩만 운다.
		※ join()
			먼저 실행하고 싶은 쓰레드에 붙인다. 다른 쓰레드를 대기 상태로 만든다.
			해당 쓰레드가 모두 종료되어야 다른 쓰레드가 실행된다.
			나중에 실행할 Thread보다 위에 있어야 함.

인코딩
	사람의 언어를 컴퓨터 언어로 바꾸는 것

	완성형
		EUC-KR
		글자 전체를 바이트로 바꿈
		각 가 갈 갛
	조합형
		UTF-8(가변형, 메모리를 효율적으로 사용함)
		자음따로 모음따로 바이트로 바꿈
		ㄱㅏㄱㄱㅏㄱㅏㄹㄱㅏㅎ

동기화(Synchronized)
	멀티 쓰레드 환경에서 특정 자원만 단일 쓰레드로 처리해야 할 경우 사용
	하나의 쓰레드가 자원을 사용하고 있을 때,
	다른 쓰레드가 동시에 같은 필드를 사용하지 못하게 막아주는 문법

	1. 동기화 키워드(메소드)
		메소드 전체가 동기화 된다.
		(단일 쓰레드로 처리)	

	2. 동기화 블럭
		블럭 내부만 동기화 된다.
		(메소드 안에 동기화 블럭이 있으면 블럭 내부만 동기화, 나머지는 동기화가 되지 않음)

	동기화를 사용하는 이유
	1. 여러 쓰레드가 하나의 자원을 공유했을 때 연산 및 다양한 문제가 발생할 수 있다.
		이 때에는 동기화를 사용하여 쓰레드가 하나씩 접근하도록 막아준다.
	2. 각 쓰레드를 제어하기 위해서
		스킬 사용하면 스킬은 비활성화 쿨타임이 활성화
		쿨타임 끝나면 비활성화 스킬 활성화

	javascript는 동기식 = 단일 쓰레드
	Ajax는 비동기식 = 멀티 쓰레드
------------------------------------------------------------------------------------------
파일 입출력
	파일 기준
		Writer(입력)
		Reader(출력)

	Java Application 기준
		Writer(출력)
		Reader(입력)

	File : 경로를 전달해주면 해당 경로의 파일의 정보를 담을 수 있다.
		1. 파일 존재 여부
		2. 해당 경로의 파일 삭제
		두 가지의 목적으로 사용

	Writer
		- BufferedWriter : 문서(텍스트, 엑셀, ...)
		- OutputStreamWriter : 파일(이미지, 동영상, ...)

		- FileWriter : 쓰기위한 목적으로 해당 경로의 파일을 열어준다.
				default로 파일 내용을 전부 지운 후 열어준다.
				만약 해당 경로에 파일이 없다면 새롭게 만든 후 가져온다.
				FileWriter("경로", 추가여부);
				추가여부는 default로 false이다. 
				따라서 매번 실행할 때 마다 전체 내용이 지워진 후 추가된다.
				true를 전달하면 기존 내용을 유지하고 맨 아래에 새로운 내용이 추가된다.

		개행은 객체명.newLine() or \n or \r\n
		운영체제별로 줄바꿈 문자가 다르다.
		이 때 자바 소스코드에 \n을 사용하여 줄바꿈을 한다면
		운영체제별로 줄바꿈이 인식되지 않는다.
		자바 프로그램은 JVM이 실행하고, JVM이 운영체제에 맞는 줄바꿈 문자로 바꿔준다.
		따라서 우리 자바개발자는 그냥 \n을 사용하면 된다.
		하지만 가끔 \n이 파일 Reader에서 잘 인식이 안될 때가 있다.
		split("\n")[0]을 했는데
		전체가 나오면 \n을 못찾았다는 이야기라서 그럴 경우 \r\n을 해야한다.

	Reader
		- BufferedReader
		- InputStreamReader

		- FileReader : 읽기 위한 목적으로 해당 경로의 파일을 열어준다.
				만약 해당 경로에 파일이 없다면 예외가 발생한다.

		//반드시 이런 구조로 사용한다.
		BufferedReader br = null;
		String line = null;
		try {
			br = new BufferedReader(new FileReader("test.txt"));
			while((line = br.readLine())!=null) {
				line = br.readLine();
				if(line == null) {
					break;
				}
				System.out.println(line);
			}
		} catch (FileNotFoundException e) {
			System.out.println("해당 경로에 파일이 존재하지 않습니다.");
		} finally {
			try {
				if(br!=null) {br.close();}
			} catch (IOException e) {
				//파일이 닫히지도 않는 경우
				throw new RuntimeException(e.getMessage());
			}
		}


	Buffer(임시 저장 공간)
		.java파일에서 .txt파일에 문자열을 작성할 때
		하나씩 전송하다 보면 효율이 떨어진다.
		따라서 전송할 데이터들을 한 번에 모은 후 일괄처리를 해야 하고,
		Buffer라는 저장공간에 모은 후 flush()를 통해 비워준다.
		파일입출력에서는 flush()만 사용하지 않고 열린 파일을 닫아주는
		close()를 사용한다. 사용 후 반드시 close()를 통해 flush를 해주어야
		작성한 내용이 파일에 적용된다.

 		일괄처리를 하기 위해 사용
		Writer를 3번할 경우 하나하나 보내는게 아니라
		버퍼에 모아두었다가 한번에 보낸다.
		버퍼는 꽉차지 않으면 보내지 않으므로 꼭 버퍼를 비워주는 flush()를 사용하기

		※ 한 번 close()를 한 객체는 new를 해도 열리지 않는다.

		버퍼링은 버퍼에 담는 중
		스트리밍은 버퍼에 담지 않고 분배기에 넣어서 한번에 뿌려주는 것


RuntimeException을 상속받은 Exception들은 실행 시 오류가 나고, 컴파일 시에는 오류가 나지 않는다.
따라서 예외처리가 강제적이지 않다.
하지만 Exception을 바로 상속받은 예외들은 어떠한 특정 로직에 의해서 컴파일 시 오류가 발생하기 때문에
반드시 예외처리를 해주어야 한다.






Buffered
MVC




	

	