프레임워크
	【뼈대나 근간을 이루는 코드들의 묶음】
	프로그램의 기본 흐름이나 구조를 정하고 모든 팀원이 이 구조에 
	자신의 코드를 추가하는 방식으로 개발하게 된다.

	프레임워크와 라이브러리의 차이
		- 프레임워크
			【제어의 주체가 프레임워크】이고,
			【프레임워크 안의 여러 기능들을 가져다 사용하는 방식】
			만약 수정해야할 경우에는 도구들을 사용해서 수정 및 추가가 가능

		- 라이브러리
			【제어의 주체가 개발자】이고,
			【핵심 로직에서 필요한 부분들만 가져다 사용하는 방식】

	장점
		회사 입장 : 일정한 품질이 보장
		개발자 입장 : 완성된 구조에 자신의 코드를 넣기 때문에 개발 시간을 단축
----------------------------------------------------------------------------------------------------------
스프링 프레임워크
	【경량 프레임워크(light-weight)】★★★
		【특정 기능을 위주로 간단한 jar파일 등을 이용해서 모든 개발이 가능하도록 구성】
	
		※ 예전 프레임워크들은 다양한 경우의 수를 처리하기 위해
			다양한 기능을 가지도록 만들다 보니 하나의 기능을 위해 사용하더라도
			모든 기능을 사용해야해서 너무 복잡하고 방대했기 때문에,
			전체를 이해하고 개발하기 어려웠다.

	장점
		- 복잡하지 않다.
		- 프로젝트 전체 구조를 설계할 때 유용하다.
		- 다른 프레임워크들을 포용한다.
			여러 프레임워크를 혼용해서 사용 가능(접착성)
		- 생산성이 올라가고 개발도구를 지원한다.

	특징
		- POJO 기반의 구성
			Plain Old Java Object
			오래된 방식의 간단한 자바 객체라는 의미
			자바 코드에서 객체를 구성하는 방식을
			스프링 프레임워크에서 그대로 사용할 수 있다는 말.
			【즉, 자바를 쓸 수 있다는 말】

		- 의존성 주입(DI)을 통한 객체 간의 관계 구성
			의존성(Dependency)
				【하나의 객체가 다른 객체 없이 제대로 된 역할을 할 수 없다는 것】
				의존성과 결합성은 비례한다.
				ex) ⓐ →→→→→→ ⓑ
					a객체에서 b객체를 직접 생성
					a가 b에 의존한다 혹은 a와 b의 결합성이 단단하다

			주입(Injection)
				【외부에서 밀어 넣는 것】
				주입을 받는 입장에서는 어떤 객체에 의존하든 자신의 역할은 변하지 않게 된다.
				ex) ⓐ →→→ ApplicationContext →→→ ⓑ
					a객체는 b객체가 필요하다는 신호만 보내고,
					b객체를 ApplicationContext가 주입한다.

			ApplicationContext★★★
				【필요한 객체들을 생성하고 주입해주는 역할】
				ApplicationContext가 있기 때문에 객체와 객체를 분리해서 생성하고,
				객체들을 엮는(wiring) 작업의 형태로 개발한다.
				ApplicationContext가 관리하는 객체들을 Bean이라 부르고,
				Bean과 Bean 사이의 의존 관계를 처리하는 방식으로
				XML설정(필수), {@ 설정, Java설정}(택1) 방식을 이용할 수 있다.

			※ 의존성 주입은 전역 변수에만 되기 때문에
				메소드에서는 new를 해야한다.
			
		- AOP 지원
			Aspect-Oriented-Programming
			【관점 지향 프로그래밍】
			횡단 관심사를 모듈(메소드)로 분리하는 프로그래밍
			비지니스 로직은 아니지만 【보안이나 로그(출력), 트랜잭션, 예외 등과 같이
			반드시 처리가 필요한 부분을 횡단 관심사(cross-concern)】이라고 한다.
			스프링 프레임워크는 횡단 관심사를 분리해서 제작하는 것이 가능하다.
				※ 종단 관삼사 : 비지니스 로직

			장점
				- 핵심 비지니스 로직에만 집중하여 코드 개발
				- 각 프로젝트마다 다른 관심사 적용 시 코드 수정 최소화
				- 원하는 관심사의 유지보수가 수월한 코드 구성 가능

		- 편리한 MVC 구조
		- WAS에 종속적이지 않은 개발 환경
		- 트랜잭션 관리 용이
			DB 작업 시 트랜잭션 관리를 매번 상황에 맞게 코드로 작성하지 않고,
			@이나 XML로 트랜잭션 관리를 설정할 수 있다.
----------------------------------------------------------------------------------------------------------
프로젝트 기본 구성 요소
	- src/main/java : 작성되는 코드의 경로(비지니스 로직 작성)
	- src/main/resources : 실행할 때 참고하는 기본 경로
	- src/test/java : 테스트 코드를 넣는 경로(테스트 하는 곳)
	- src/text/resources : 테스트 관련 설정 파일 보관 경로

웹과 관련된 스프링 설정 파일(Resources, ViewResolver)
	src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml
	요청과 응답을 처리해준다.

스프링 설정 파일(Bean, IoC 컨테이너)
	src/main/webapp/WEB-INF/spring/root-context.xml

	※ IoC : 제어권의 역전
		객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것

	※ IoC 컨테이너 : 객체에 대한 생성 및 생명주기를 관리할 수 있는 기능을 제공
			컨테이너가 흐름의 주체가 된다.

Tomcat의 web.xml 파일(Front-Controller, DispatcherServlet)
	src/main/webapp/WEB-INF/web.xml

템플릿 프로젝트의 jsp 파일
	src/main/webapp/WEB-INF/views

Maven이 사용하는 pom.xml
	project/pom.xml
	
	※ Maven : 자바용 프로젝트 관리도구로,
			필요한 라이브러리를 pom.xml에 정의해 놓으면
			내가 사용할 라이브러리 뿐만 아니라 해당 라이브러리가 작동하는데에
			필요한 다른 라이브러리들까지 관리하여 네트워크를 통해
			자동으로 다운받아 준다.
	※ pom : Project Object Model
----------------------------------------------------------------------------------------------------------
@Component
	스프링에게 해당 클래스가 스프링에서 관리해야 하는 대상임을 표시
	보통 Model 객체에 다 붙여준다.

	@Component가 있는 패키지 등록
		root-context.xml > 하단의 Namespace > context 체크
		> Source에 <context:component-scan base-package="@Component가 있는 패키지명"/>
		@만 붙이고 패키지를 등록하지 않으면 의미가 없다.
		
@Data
	Lombok이 setter, getter, 생성자, toString() 등을 자동으로 생성
	만약 getter만 필요하면 @Getter로 별도 생성도 가능하다.

@Setter(onMethod_ = @Autowired)
private 클래스명 객체명;
	해당 클래스의 생성자를 가져와서 할당한다.
	※ onMethod : 생성되는 setter에 @Autowired를 추가하도록 할 때 사용
			버전에 따라 다르기 때문에 오류나면 _를 추가한다.

※ S가 아이콘에 없으면 @Component를 안했거나, root-context.xml에 패키지 등록을 안한 것
※ root-context.xml에서 코드색이 변하지 않는 경우
	root-context.xml 우클릭 > Open with > Spring Config Editor
----------------------------------------------------------------------------------------------------------
스프링 프레임워크 동작 시 생기는 일
	1. 스프링이 사용하는 메모리 영역을 만든다(Context).
	2. 스프링은 자신이 객체를 생성하고 관리해야 하는 객체들에 대한 설정이 필요하고,
		이 설정 파일이 root-context.xml이다.
	3. root-context.xml에 작성한 <context:component-scan>의 내용을 통해서
		패키지를 스캔하기 시작한다.
	4. 해당 패키지에 있는 클래스들 중에서 @Component가 존재하는 클래스의 인스턴스를 생성한다.
	5. @Setter(onMethod_ = @Autowired) 처리
----------------------------------------------------------------------------------------------------------
테스트 서버
	src/test/java에 생성
	
	@RunWith(SpringJUnit4ClassRunner.class)
		테스트 코드가 스프링을 실행

	@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
		지정된 클래스나 문자열을 이용해서 【필요한 객체들을 스프링 내에 객체로 등록】

	@Log4j
		private static final Logger logger = LoggerFactory.getLogger(HomeController.class)와 동일
		Log.info() == System.out.println()

	assertNotNull(객체명);
		객체명이 Null이 아니어야만 테스트 성공
		만약 Null이라면 밑에 코드들은 실행되지 않음

	@AllArgsConstructor
		인스턴스 변수로 선언된 모든 것을 파라미터로 받는 생성자를 생성
		만약 @NonNull이 있다면 예외처리도 자동 생성
		ex)
			private String s1;
			private String s2;
			@NonNull
			private String s3;

			public 클래스명(String s1, String s2, String s3){
				if(t3 == null){
					throw new NullPointException();
				} else {
					this.t1 = t1;
					this.t2 = t2;
					this.t3 = t3;		
				}
			}

	@RequiredArgsConstructor
		@NonNull이나 final이 붙은 변수에 대한 생성자를 생성
		ex)
			private String s1;
			private final String s2;
			@NonNull
			private String s3;

			public 클래스명(String s2, @NonNull String s3){
				if(t3 == null){
					throw new NullPointException();
				} else {
					this.t2 = t2;
					this.t3 = t3;		
				}
			}
----------------------------------------------------------------------------------------------------------
try(Statement)
	Statement 자리에 close를 필요로 하는 인스턴스를 작성하면 자동으로 close() 한다.
	ex)
		try(Connection conn = 
			DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE",	
			"hr",
			"hr")){
			Log.info(conn);
		}catch(Exception e){
			fail(e.getMessage());
		}

		※ fail() : 테스트를 종료

<bean id="" class="" destroy-method="">
	객체를 생성하는 태그
	@Component, @Service 등과 동일
	id에는 객체명,
	class에는 패키지명.클래스명,
	destory-method에는 종료 시 사용할 메소드

	만일 여러 개의 자식 클래스가 있을 경우
	@을 여러개 사용하는게 아니라 <bean>으로 생성하되,
	id를 다르게 입력하고 @Autowired(required=false) @Qualifier("id")를 사용한다.
	

<constructor-arg ref="참조할 객체명"/>
----------------------------------------------------------------------------------------------------------
SQL문을 항상 인터페이스에 매핑
	SQL이 복잡하거나 길어지는 경우에는 @보다는 XML을 이용하는 방식을 더 선호하게 된다.
	MyBatis-Spring의 경우 Mapper 인터페이스와 XML을 동시에 이용할 수 있다.

	root-context.xml
		<mybatis-spring:scan base-package="패키지명"/> 추가

	1. XML을 이용할 경우
		src/main/resources/META-INF안에 폴더를 생성하고 xml 파일 생성
			여기서 폴더는 오류가 날 수 있으므로 하나씩 개별 생성
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 추가
		
		<mapper namespace="인터페이스가 있는 패키지와 인터페이스 이름">
		id에는 인터페이스에 있는 추상메소드의 이름을 쓴다.
		나머지는 model2 방식과 동일
		
		※ 스프링에서는 parameterType을 적지 않는다.
			(insert, update, delete는 id만 적으면 되는 것)

	2. 인터페이스
		@Select("쿼리문")
			이 부분에 쿼리문을 작성한다.
			SELECT면 @Select, DELETE면 @Delete
		public String 추상메소드명();
			【추상메소드가 실행되면 쿼리문이 실행되는 것】

		※ 사용은 컨트롤러에서 인터페이스만 객체화해서 사용

	※ 추상메소드 당 쿼리문 하나
----------------------------------------------------------------------------------------------------------
MVC model2를 사용하는 이유
	- 분업★★★
	- 유지보수
	- 페이지가 많기 때문에

(Spring MVC)Front-Controller 패턴
	            HandlerMapping
	        ①          ↕②        ③                      ④
	Client ↔ DispatcherServlet ↔ HandlerAdapter ↔ Controller
	        ⑥          ↕⑤
	              ViewResolver
	
	진행 순서(↑와 다름)
		1) 사용자의 모든 Request(URL)는 Front-Controller인 DispatcherServlet을 통해 처리한다(web.xml).
		2) HandlerMapping은 Request의 처리를 담당하는 컨트롤러를 찾기 위해 존재한다.
			@RequestMapping, @Controller가 적용된 것을 기준으로 판단하며,
			적절한 컨트롤러가 찾아졌다면 HandlerAdapter를 이용해서
			해당 컨트롤러를 동작시킨다.
			※ @XXXXMapping() : 요청이 매개변수에 있는 값이면 들어와라
			※ @Controller : 자동으로 스프링의 객체(Bean)로 등록된다.
			
			ex)
			- RequestMapping("/sample/*")
				sample로 시작하는 모든 애들은 이쪽으로 들어온다.

			- RequestMapping("")
				들어온 것 중에 sample뒤에 아무것도 없는 경우 들어온다.

			- RequestMapping(value="/basic", method={RequestMethod.GET, RequestMethod.POST})
				여러 개의 응답 방식을 사용할 경우 url은 value에 담아준다.

			※ RequestMapping은 GET과 POST 둘 다 사용할 경우만 쓴다.
				
			@GetMapping("/basicOnlyGet")
				GET방식으로 요청한 것만 들어온다.

			@PostMapping("/basicOnlyPost")
				POST방식으로 요청한 것만 들어온다.

		3) Controller는 Request를 처리하는 비지니스 로직을 작성하며,
			View에 전달해야 하는 데이터는 주로 Model 객체에 담아서 전달한다.
		4) ViewResolver는 Controller가 리턴한 결과를 
			어떤 View에서 처리하는 것이 좋을 지 해석하는 역할(servlet-context.xml)
		5) 만들어진 응답은 DispatcherServlet을 통해서 전송된다.

	※ 내가 생각한 순서
		사용자에게 요청(URL)이 들어오면 web.xml은 모든 URL을 DispatcherServlet으로 보내는데
		그 과정에서 servlet-context.xml에 가서 <context:component-scan>에 들어있는 패키지로 가서
		@Controller가 붙어있는 컨트롤러들을 객체화하고 @OOOMapping 중 어떤걸 실행할지 찾아서
			이 부분이 HandlerMapping
		실행 후 view와 model을 응답함
		그럼 다시 DispatcherServlet으로 돌아와서 컨트롤러에서 받은 view에 servlet-context.xml을 참고하여
		리턴값 앞에는 prefix, 뒤에는 suffix를 붙여서 어떤 jsp에 응답할지 알아낸 후 model을 넘겨준다.
			이 부분이 ViewResolver

		servlet-context.xml은 HandlerMapping과 ViewResolver 둘 다 사용하는 것

	
Spring MVC Controller 특징
	- HttpServletRequest, HttpServletResponse를 거의 사용할 필요가 없다.
	- 다양한 타입의 파라미터 처리, 다양한 타입의 리턴 타입 사용 가능
	- GET, POST 등 전송 방식에 대한 처리를 @으로 가능
	- 상속/인터페이스 방식 대신 @만으로도 설정 가능

Model(데이터 전달자)
	Model 객체는 컨트롤러에서 생성된 데이터를 담아서 JSP에 전달하는 역할
	반면 기본 자료형의 경우 파라미터로 선언하더라도 화면까지 전달되지 않는다.
		내가 만든 클래스 객체는 Model을 안붙여도 된다.
		자바에서 제공하는건 Model을 붙여야 한다.
			ex) String, int, ArrayList, [] 등
	Model은 Servlet의 request 내장 객체를 사용한다.

	@GetMapping("/ex01")
	public String ex01(SampleDTO dto){ }
		파라미터 타입에 따라 자동으로 매핑된다.

	@GetMapping("/ex02")
	public String ex02(@RequestParam("data1") String name, @RequestParam("data2") ing age, Model model){ }
		파라미터와 매개변수의 이름이 다를 경우 사용
		쿼리스트링에 key가 data1이면 name에, data2면 age에 담는다.
		그냥 name과 age를 사용할꺼면 @RequestParam()을 지운다.

		또는 매개변수로 변수와 객체를 받았을 경우,
			변수를 찾으면 객체부터 가서 변수를 찾기 때문에 오류가 발생해서
			여기 변수가 있다고 @RequestParam으로 알려주는 것
	

	@GetMapping("/ex03")
	public String ex03(@RequestParam("data") ArrayList<String> datas, Model model){ }
		쿼리스트링에 key가 data면 datas라는 ArrayList에 담는다.

	@GetMapping("/ex04")
	public String ex04(@RequestParam("data") String[] datas, Model model){ }
		쿼리스트링에 key가 data면 datas라는 String[]에 담는다.

	@GetMapping("/ex05")
	public void ex05(SampleDTO dto, @ModelAttribute("gender") String gender){ }
		참조형과 기본형을 같이 사용할 수 있다.
		※ 요청한 경로와 같은 경로로 리턴하는 경우 void를 사용해도 된다.
			다른 경로로 리턴하는 경우 리턴을 써준다.

	※ model.addAttribute(Object value)
		해당 객체의 클래스 타입에서 앞글자가 소문자로 바뀐 단어가 KEY값이 된다.
----------------------------------------------------------------------------------------------------------
예외처리
	예외 발생 시 해당 예외 필드가 메모리에 할당된다.
	할당된 예외 필드의 주소값을 받을 객체가 필요하므로
	매개변수에 Exception타입의 e 객체를 선언해놓는다.

	@ExceptionHandler(Exception.class)
	public void temp(){}
		매개변수에 있는 예외가 발생되면 메소드를 실행한다.
		{예외1, 예외2}처럼 2개를 넣을 수도 있다.

	@ControllerAdvice
		해당 객체가 스프링의 컨트롤러에서 발생하는 【예외를 처리하는 존재임을 명시하는 것】

	【500메세지는】 Internal Server Error이므로 【@ExceptionHandler를 이용해서 처리가 가능】하지만
	【404메세지는】 잘못된 URL을 호출할 때 보이므로 【예외가 나지 않기 때문에 예외를 발생시켜야 한다.】
		404가 났을 때 예외가 발생하는 옵션
			<param-name>throwExceptionIfNoHandlerFound</param-name>
			<param-value>true</param-value>
				예외를 발생시킬꺼니? true/false

	@ResponseStatus(HttpStatus.NOT_FOUND)
		404는 자동으로 status가 넘어가지 않기 때문에
		【status를 직접 전달해주어야 한다.】
			하지 않으면 StackOverFlow가 뜬다.

	만들어둔 예외처리를 다른 프로젝트에서 사용할 경우
		web.xml, root-context.xml, src/java/main의 exception 패키지를 복붙한다.
----------------------------------------------------------------------------------------------------------
스프링 MVC 프로젝트의 기본 구성
	스프링 MVC에서 어떤 단계를 거쳐서 실행되는 지를 이해해야
	문제 발생 시 빠른 대처와 대안을 찾을 수 있다.

	3-tire방식
		     View	          Java            DB
		Presentation ↔ Business ↔ Persistence
		      ①               ②             ③

		[Presentation Tier(화면 계층)]
			【화면에 보여주는 기술을 사용하는 영역】
			Servlet/JSP 혹은 스프링 MVC가 담당하는 영역이며 화면 구성이 이에 속한다.

		[Business Tier(비지니스 계층)]
			【순수한 비지니스 로직을 담고 있는 영역】
			클라이언트의 요구사항을 반영하는 영역
			OOOService와 같은 이름으로 구성한다.
			
			Presentation Tire와 Persistence Tire의 중간다리 역할
			예를 들어 상품 구매 시 포인트 적립을 한다면
			Persistence Tire의 설계는 '상품', ''회원으로 나누어 설계하지만
			Business Tire는 '상품', '회원'을 동시에 사용해서 하나의 로직으로 처리하게 된다.
			즉, 하나의 트랜잭션에 여러 개의 쿼리문이 필요하기 때문에
				메소드를 여러개 사용해야 하지만
				Service에 사용해야 할 메소드들을 넣어놓고
				Service 한 번만 사용하여 메소드를 여러개 사용하는 효과를 내는 것
				【컨트롤러에서는 mapper가 아닌 service만 사용한다.】

				인터페이스 없이 클래스만 만들 수 있지만
					【재사용을 하기 위해】 인터페이스를 연결해서 사용한다.

		[Persistence Tire(영속 계층 or 데이터 계층)]
			【데이터의 보관 방식과 사용에 대한 영역】
			일반적으로 DB를 많이 이용하지만,
				상황에 따라 네트워크 호출 or 원격 호출 등의 기술이 접목된다.

		각 영역은 독립적으로 설계되어 쉽게 교체가 가능하다.
		각 연결 부위는 인터페이스를 이용해서 설계하는 것이 일반적인 구성이다.
----------------------------------------------------------------------------------------------------------
Naming Convention(명명 규칙)
	config : 		프로젝트와 관련된 설정 클래스들을 보관하는 패키지
	controller :	스프링 MVC의 Controller들을 보관하는 패키지
	service : 		스프링 Service 인터페이스와 클래스를 보관하는 패키지
	domain : 		VO, DTO를 보관하는 패키지
				테이블의 컬럼이랑 필드가 일치하면 VO
				그 외에는 DTO
				VO와 DTO는 의존성 주입을 하지 않기 때문에
				@Component를 쓰지 않는다.
	persistence : 	Mybatis Mapper 인터페이스 패키지
	exception : 	웹 관련 예외처리 패키지
	aop : 		AOP 관련 패키지
	security : 	Security 관련 패키지(자동 로그인, 세션 종료 등)
	util : 		각종 유틸리티 관련 패키지
----------------------------------------------------------------------------------------------------------
PK값을 미리 SQL을 통해서 처리하는 방식
	SQL을 한 번 더 실행하는 부담이 있기는 하지만
	자동으로 추가되는 PK값을 확인해야 하는 상황에서는 유용하게 사용될 수 있다.

	예시)
	<insert id="insertSelectKey_bno">
		<selectKey keyProperty="bno" order="BEFORE" resultType="Long">
			SELECT SEQ_BOARD.NEXTVAL FROM DUAL
		</selectKey>		
			※ Key Property : 가져온 key값을 넣을 필드명
			※ order="BEFORE" : 가장 먼저 실행한다는 의미
		※ 여기까지만 먼저 실행되고 bno에 결과값이 들어간 후 다음 SQL이 실행되는 것★
		INSERT INTO TBL_BOARD(BNO, TITLE, CONTENT, WRITER)
		VALUES(#{bno}, #{title}, #{content}, #{writer})
	</insert>
----------------------------------------------------------------------------------------------------------
스네이크표기법(_)를 카멜표기법으로 바꿔주는 라이브러리
	root-context.xml의 <bean id="sqlSessionFactory">안에
	<property name="configuration">
		<bean class="org.apache.ibatis.session.Configuration">
			<property name="mapUnderscoreToCamelCase" value="true"/>
		</bean>
	</property>
----------------------------------------------------------------------------------------------------------
Tomcat 없이 컨트롤러 테스트 하는 방법
	【WebApplicationContext가 항상 가장 먼저 메모리에 할당된다.】
		할당되지 않으면 아무것도 할 수 없다.
	톰캣을 사용하면 WebApplicationContext가 설정되지만,
	톰캣을 사용하지 않는 경우 직접 설정해야 한다.

	@WebAppConfiguration : Servlet의 ServletContext를 이용한다.
	@ContextConfiguration({
		"file:src/main/webapp/WEB-INF/spring/root-context.xml",
		"file:src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml"
	})

MockMVC
	가짜 MVC
	마치 브라우저에서 사용하는 것처럼 만들어서 Controller를 실행
	【주입을 받지 않고 WebApplicationContext를 통해 빌드한다.】

	빌드)	
	@Setter(onMethod_ = @Autowired)
	private WebApplicationContext wad;

	private MockMVC mockMvc;
	@Before // 가장 먼저 실행
	public void setUp(){
		this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
	}

	사용1, Model로 넘긴 경우)
	mockMvc.perform(MockMvcRequestBuilders.get("/board/list")
			.param(key, value)
				//컨트롤러로 파라미터를 넘겨야 하는 경우 사용
		.andReturn()
		.getModelAndView() // 모델에 리턴받은 데이터를 맵 형식으로 확인
		.getModelMap());

	사용2, Flash로 넘긴 경우)
	mockMvc.perform(MockMvcRequestBuilders.update("/board/update")
			.param(key, value)
		.andReturn()
		.getFlashMap()); // Flash를 사용했으면 여기서도 FlashMap을 사용한다.

	※ 만약 오류가 발생할 경우
		pom.xml에서
		94번 줄에 <artifactId>javax.servlet-api</artifactId>
		95번 줄에 <version>3.1.0</version>
----------------------------------------------------------------------------------------------------------
Redirect로 응답
	컨트롤러에서 return에 "rediect:/경로'
		'rediect:' == response.sendRedirect()
		default는 forward 방식

	Redirect 방식은 request를 초기화하므로
		Model 객체의 addAttribute()가 아닌,
		RedirectAttributes 객체의 addFlashAttribute()를 사용한다.

	Flash
		Redirect는 request가 초기화 되기 때문에
		페이지를 이동할 때 Session의 Flash 영역에 잠시 데이터를 맡겨두고
		페이지 이동 후 꺼내오는 방식이다. (데이터를 꺼내면 Flash 영역은 비어있음)
		단, Flash 영역에는 남용을 방지하기 위해서
			addFlashAttribute()는 한 번만 사용할 수 있는데
			다른 데이터를 넘겨야 하는 경우 쿼리스트링 방식을 이용해야 하는데
			그 때 RedirectAttributes 객체의 addAttribute()를 사용하면
			자동으로 쿼리스트링에 붙게된다.
----------------------------------------------------------------------------------------------------------
게시판에서 글 등록 시 한글이 깨지는 경우
	web.xml에 밑에 코드를 추가한다.
	<filter>
		<filter-name>encoding</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>   
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
   
	<filter-mapping>
		<filter-name>encoding</filter-name>
		<servlet-name>appServlet</servlet-name>
	</filter-mapping>	
----------------------------------------------------------------------------------------------------------
화면 페이징 처리
	ORDER BY보다 인덱스를 사용하면 정렬을 생략할 수 있다.
		인덱스가 이미 정렬된 구조이기 때문이다.
		예를 들어 테이블이 하나의 책이라면,
			인덱스는 각 페이지 번호를 의미한다.
		인덱스를 통해서 원하는 내용을 위에서부터 혹은 밑에서부터 찾아나가는 것을 scan이라고 한다.

	Hint
		SELECT문에 실행하고 싶은 계획을 전달할 때 사용하는 문법
		/*+ Hint(테이블명 PK명) */
			【()안에 쉼표(,)는 사용하지 않는다.】
	
		주의)
		잘못 작성되어도 실행할 때에는 무시되며 별도의 오류가 발생하지 않는다.

	※ ROWID : 행 마다 부여되는 주소값

	예시)
	<select id="getListWithPaging" resultType="com.koreait.domain.BoardVO">
		SELECT BNO, TITLE, CONTENT, WRITER
			//여기서 *을 안쓰고 컬럼명을 쓴 이유는 
				*보다 컬럼명을 쓰는게 속도가 훨씬 빠르기 때문이다.
		FROM
			(SELECT /*+ INDEX_DESC(TBL_BOARD PK_BNO) */
				ROWNUM RN, BNO, TITLE, CONTENT, WRITER
				FROM TBL_BOARD WHERE ROWNUM <![CDATA[<=]]> #{pageNum} * #{amount})
		WHERE RN <![CDATA[>]]> (#{pageNum} - 1) * #{amount}
	</select>

	※ Criteria : 검색의 기준
	※ Math.ceil() : 올림(3.1이면 4)	
----------------------------------------------------------------------------------------------------------
MyBatis의 동적 태그
	<if>
		<if test="">
			쿼리문
			//조건이 참이어야만 쿼리문이 실행된다.
		</if>
		

	<choose>
		<choose>
			<when test="">
				쿼리문
				//조건이 참일 경우 실행				
			</when>
			<otherwise>
				쿼리문
				//모든 <when>이 거짓일 경우 실행
			</otherwise>
		</choose>

	<where>
		<where>
			<if test="">
				쿼리문
			</if>
			//<where>안에 쿼리문이 있을 경우 WHERE절을 생성,
				쿼리문이 없을 경우 WHERE절을 생성하지 않는다.
				여기서는 <if>가 참이면 <where>가 WHERE를 만들어서 쿼리문을 붙이고,
				<if>가 거짓이면 <where>가 WHERE절을 만들지 않는다.
		</where>

	<trim>
		prefixOverrides, suffixOverrides
			쿼리문 맨 앞(맨 뒤)에 필요하면 넣어주고 필요없으면 빼주는 것
			앞(뒤)의 조건식의 유무에 따라 결정된다.
			prefix(suffix) / Overrides로 나눠서
				일단 만들고 조건식의 유무에 따라 빼는 형식으로 생각해도 된다.

		prefix : 앞에 무조건 붙여라.
		suffix : 뒤에 무조건 붙여라.

		예시)
		SELECT * FROM TBL_BOARD
			<where>
				<if test="bno != null">
					BNO = #{bno}
				</if>
				<trim prefixOverrides="AND">
					ROWNUM = 1
				</trim>
			</where>
			bno가 null일 경우
				SELECT * FROM TBL_BOARD WHERE ROWNUM = 1
			bno가 null이 아닐 경우
				SELECT * FROM TBL_BOARD WHERE BNO = #{bno} AND ROWNUM = 1				
			
	<foreach>	
		List, 배열, Map 등을 이용해서 반복
		<foreach item="" index="" collection="">
			item은 value값이 담길 변수
			index는 현재 index(Map이면 key)
			collection은 List, 배열, Map등이 담길 변수
		</foreach>

	※ | : 파이프 연산자 혹은 Concatenation(연결)
		하나의 문자열로 연결해주는 역할

	※ split()에 구분점을 전달하지 않으면 문자 하나하나가 분리된다.
		String temp = "CAT";
		temp.split(); 하면 C, A, T가 담긴 3칸짜리 배열

	※ 서브쿼리를 ()로 묶는 이유는 가독성 때문, 다른 이유는 없다.
----------------------------------------------------------------------------------------------------------
XML에서 쿼리문을 재사용
	<sql id="">
		재사용 할 쿼리문
	</sql>으로 만들고
	사용하는 곳에서 <include refid="id"/>를 쓴다.
----------------------------------------------------------------------------------------------------------
UriComponentsBuilder
	쿼리스트링을 만들어주는 라이브러리
	여러 개의 파라미터들을 연결하여 URL 형태로 만들어주는 기능
	
	예시)
	public String getListLink(){
		UriComponentBuilder builder = UriComponentsBuilder.fromPath("")
			.queryParam("key", value)
			//쿼리스트링에 추가할 key와 value

		return builder.toUriString();
	}

	사용)
	?pageNum=${pageMaker.cri.getListLink()}&amount=${pageMaker.cri.getListLink()}를
	${pageMaker.cri.getListLink()}로 사용할 수 있다.

	※ 맨 앞에 ?가 반드시 붙기 때문에
		다른 쿼리스트링이 있다면 만들어둔 UriComponentsBuilder 뒤에 &를 하고 붙여준다.
----------------------------------------------------------------------------------------------------------
※ jsp에서 EL문을 사용할 때 getter 대신 필드명을 사용할 수 있다.
	${board.getBno()} == ${board.bno}

※ jsp에서 톰캣의 모듈이 "/"가 아닌 "/board"라면
	<script src="/resources/assets/js/jquery.min.js"/>를
	<script src="/board/resources/assets/js/jquery.min.js"/>로 수정해야 한다.

※ 컨트롤러에서 동일한 코드를 다른 곳에서도 사용할 경우
	새로 만드는 것이 아니라 경로에 추가한다.
	@GetMapping({"/list", "modify"})
	
※ 인라인으로 속성을 적용하면 미디어쿼리에서 적용이 안되는 경우가 생기니까 <style>에 적용하기

※ 컨트롤러에 있는 클래스 타입의 매개변수는 생성자를 통해서 파라미터 값으로 초기화 한다.
	만약 전달받은 파라미터 값에 매핑되는 생성자가 없다면 값을 전달받을 수 없다.
	따라서 【반드시 해당 객체의 생성자에 전달할 필드명과 일치하도록 설정해준다.】
	
	예시)
	rttr.addFlashAttribute("cri", cri) (x)
	rttr.addFlashAttribute("pageNum", pageNum) (o)
	rttr.addFlashAttribute("amount", amount) (o)

※ javascript:void(0) : 디자인만 살려두고 기능은 없애주는 것

※ 조건식에 val()을 쓰면 값을 불러오는게 아니라 값이 있냐 없냐가 된다.

※ QR 만드는 법
	첫번째 방법)
		https://ko.qr-code-generator.com/?ut_source=
		google_c&ut_medium=cpc&ut_campaign=&ut_content=&ut_term
		=%2Bqr%20%2B%EB%A7%8C%EB%93%A4%EA%B8%B0_b&gclid
		=CjwKCAjw-e2EBhAhEiwAJI5jgxXRBXRSgycN6cBl5WpgSpo
		WarMIMghhgEGmFK0Vi6Bb3hKa44jZzBoCINoQAvD_BwE
		가서 URL 입력하거나

	두번째 방법)
		https://www.miricanvas.com/ 가서 만들기 들어가서 더보기에 QR코드 URL 입력

※ 전자정부표준프레임워크(egov)
	정부 공공 프로젝트 등 상용화 혹은 서비스해야할 상품을 제작할 때
	표준 라이브러리만 제공해준다.

※ @RunWith(SpringRunner.class)
	SpringJUnitClassRunner의 자식이며,
	4.3버전 이상부터 사용 가능한 확장판이다.
----------------------------------------------------------------------------------------------------------
웹 디자이너 : 	포토샵, 일러스트 파일로 웹 개발에 필요한 요소 디자인
			레이아웃, 폰트 등을 결정하는 것
퍼블리셔 : 	한국에만 있는 직종
			프론트 엔드 개발자를 도와주는 역할
프론트 엔드 : 	백에서 요청한 뷰를 알맞게 응답
		퍼블리셔가 Node를 하면 프론트 엔드
백엔드 : 		REST
풀스택 : 		백 + 프론트 + 엔드

※ 엔드 : 서버

※ 【REST : 데이터를 파라미터로 전달하는게 아니라 JSON 파일로 전달하는 것】

※ 프론트에 문제가 생기면 프론트 엔드가 아니라 퍼블리셔에게 가야한다.

프로젝트 순서
	1. 웹 디자인 포토샵 파일 완성
	2. 프론트 엔드 개발자가 각 요소를 디자인에서 분리
	3. 백 엔드 개발자가 해당 이미지를 사용

	클라이언트 → 백 단 서버 → 연산, 동적데이터 처리
	→ 응답 → 프론트 요청 → 프론트 응답 → 백 단 응답

※ 렌더링 : 브라우저에서 해석해서 뿌려주는 것