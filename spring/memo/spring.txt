프레임워크
	【뼈대나 근간을 이루는 코드들의 묶음】
	프로그램의 기본 흐름이나 구조를 정하고 모든 팀원이 이 구조에 
	자신의 코드를 추가하는 방식으로 개발하게 된다.

	프레임워크와 라이브러리의 차이
		- 프레임워크
			【제어의 주체가 프레임워크】이고,
			【프레임워크 안의 여러 기능들을 가져다 사용하는 방식】
			만약 수정해야할 경우에는 도구들을 사용해서 수정 및 추가가 가능

		- 라이브러리
			【제어의 주체가 개발자】이고,
			【핵심 로직에서 필요한 부분들만 가져다 사용하는 방식】

	장점
		회사 입장 : 일정한 품질이 보장
		개발자 입장 : 완성된 구조에 자신의 코드를 넣기 때문에 개발 시간을 단축
----------------------------------------------------------------------------------------------------------
스프링 프레임워크
	【경량 프레임워크(light-weight)】★★★
		【특정 기능을 위주로 간단한 jar파일 등을 이용해서 모든 개발이 가능하도록 구성】
	
		※ 예전 프레임워크들은 다양한 경우의 수를 처리하기 위해
			다양한 기능을 가지도록 만들다 보니 하나의 기능을 위해 사용하더라도
			모든 기능을 사용해야해서 너무 복잡하고 방대했기 때문에,
			전체를 이해하고 개발하기 어려웠다.

	장점
		- 복잡하지 않다.
		- 프로젝트 전체 구조를 설계할 때 유용하다.
		- 다른 프레임워크들을 포용한다.
			여러 프레임워크를 혼용해서 사용 가능(접착성)
		- 생산성이 올라가고 개발도구를 지원한다.

	특징
		- POJO 기반의 구성
			Plain Old Java Object
			오래된 방식의 간단한 자바 객체라는 의미
			자바 코드에서 객체를 구성하는 방식을
			스프링 프레임워크에서 그대로 사용할 수 있다는 말.
			【즉, 자바를 쓸 수 있다는 말】

		- 의존성 주입(DI)을 통한 객체 간의 관계 구성
			의존성(Dependency)
				【하나의 객체가 다른 객체 없이 제대로 된 역할을 할 수 없다는 것】
				의존성과 결합성은 비례한다.
				ex) ⓐ →→→→→→ ⓑ
					a객체에서 b객체를 직접 생성
					a가 b에 의존한다 혹은 a와 b의 결합성이 단단하다

			주입(Injection)
				【외부에서 밀어 넣는 것】
				주입을 받는 입장에서는 어떤 객체에 의존하든 자신의 역할은 변하지 않게 된다.
				ex) ⓐ →→→ ApplicationContext →→→ ⓑ
					a객체는 b객체가 필요하다는 신호만 보내고,
					b객체를 ApplicationContext가 주입한다.

			ApplicationContext★★★
				【필요한 객체들을 생성하고 주입해주는 역할】
				ApplicationContext가 있기 때문에 객체와 객체를 분리해서 생성하고,
				객체들을 엮는(wiring) 작업의 형태로 개발한다.
				ApplicationContext가 관리하는 객체들을 Bean이라 부르고,
				Bean과 Bean 사이의 의존 관계를 처리하는 방식으로
				XML설정(필수), {@ 설정, Java설정}(택1) 방식을 이용할 수 있다.

			※ 【의존성 주입은 전역 변수에만】 되기 때문에★
				메소드에서는 new를 해야한다.
			
		- AOP 지원
			Aspect-Oriented-Programming
			【관점 지향 프로그래밍】
			횡단 관심사를 모듈(메소드)로 분리하는 프로그래밍
			비지니스 로직은 아니지만 【보안이나 로그(출력), 트랜잭션, 예외 등과 같이
			반드시 처리가 필요한 부분을 횡단 관심사(cross-concern)】이라고 한다.
			스프링 프레임워크는 횡단 관심사를 분리해서 제작하는 것이 가능하다.
				※ 종단 관삼사 : 비지니스 로직

			장점
				- 핵심 비지니스 로직에만 집중하여 코드 개발
				- 각 프로젝트마다 다른 관심사 적용 시 코드 수정 최소화
				- 원하는 관심사의 유지보수가 수월한 코드 구성 가능

		- 편리한 MVC 구조
		- WAS에 종속적이지 않은 개발 환경
		- 트랜잭션 관리 용이
			DB 작업 시 트랜잭션 관리를 매번 상황에 맞게 코드로 작성하지 않고,
			@이나 XML로 트랜잭션 관리를 설정할 수 있다.
----------------------------------------------------------------------------------------------------------
프로젝트 기본 구성 요소
	- src/main/java : 작성되는 코드의 경로(비지니스 로직 작성)
	- src/main/resources : 실행할 때 참고하는 기본 경로(mapper.xml 있는 곳)
	- src/test/java : 테스트 코드를 넣는 경로(테스트 하는 곳)
	- src/text/resources : 테스트 관련 설정 파일 보관 경로

웹과 관련된 스프링 설정 파일(Resources, ViewResolver)
	src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml
	요청과 응답을 처리해준다.

스프링 설정 파일(Bean, IoC 컨테이너)
	src/main/webapp/WEB-INF/spring/root-context.xml

	※ IoC : 제어권의 역전
		객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것

	※ IoC 컨테이너 : 객체에 대한 생성 및 생명주기를 관리할 수 있는 기능을 제공
			컨테이너가 흐름의 주체가 된다.

Tomcat의 web.xml 파일(Front-Controller, DispatcherServlet)
	src/main/webapp/WEB-INF/web.xml

템플릿 프로젝트의 jsp 파일
	src/main/webapp/WEB-INF/views

Maven이 사용하는 pom.xml
	project/pom.xml
	
	※ Maven : 자바용 프로젝트 관리도구로,
			필요한 라이브러리를 pom.xml에 정의해 놓으면
			내가 사용할 라이브러리 뿐만 아니라 해당 라이브러리가 작동하는데에
			필요한 다른 라이브러리들까지 관리하여 네트워크를 통해
			자동으로 다운받아 준다.
	※ pom : Project Object Model
----------------------------------------------------------------------------------------------------------
@Component
	스프링에게 해당 클래스가 스프링에서 관리해야 하는 대상임을 표시
	객체(bean)를 생성하기 위해 만드는 것
	보통 Model 객체에 다 붙여준다.

	@Component가 있는 패키지 등록
		root-context.xml > 하단의 Namespace > context 체크
		> Source에 <context:component-scan base-package="@Component가 있는 패키지명"/>
		@만 붙이고 패키지를 등록하지 않으면 의미가 없다.
		
@Data
	Lombok이 setter, getter, 생성자, toString() 등을 자동으로 생성
	만약 getter만 필요하면 @Getter로 별도 생성도 가능하다.

@Setter(onMethod_ = @Autowired)
private 클래스명 객체명;
	해당 클래스의 생성자를 가져와서 할당한다.
	※ onMethod : 생성되는 setter에 @Autowired를 추가하도록 할 때 사용
			버전에 따라 다르기 때문에 오류나면 _를 추가한다.

※ S가 아이콘에 없으면 @Component를 안했거나, root-context.xml에 패키지 등록을 안한 것
※ root-context.xml에서 코드색이 변하지 않는 경우
	root-context.xml 우클릭 > Open with > Spring Config Editor
----------------------------------------------------------------------------------------------------------
스프링 프레임워크 동작 시 생기는 일
	1. 스프링이 사용하는 메모리 영역을 만든다(Context).
	2. 스프링은 자신이 객체를 생성하고 관리해야 하는 객체들에 대한 설정이 필요하고,
		이 설정 파일이 root-context.xml이다.
	3. root-context.xml에 작성한 <context:component-scan>의 내용을 통해서
		패키지를 스캔하기 시작한다.
	4. 해당 패키지에 있는 클래스들 중에서 @Component가 존재하는 클래스의 인스턴스를 생성한다.
	5. @Setter(onMethod_ = @Autowired) 처리
----------------------------------------------------------------------------------------------------------
테스트 서버
	src/test/java에 생성
	
	@RunWith(SpringJUnit4ClassRunner.class)
		테스트 코드가 스프링을 실행

	@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
		지정된 클래스나 문자열을 이용해서 【필요한 객체들을 스프링 내에 객체로 등록】

	@Log4j
		private static final Logger logger = LoggerFactory.getLogger(HomeController.class)와 동일
		Log.info() == System.out.println()

	assertNotNull(객체명);
		객체명이 Null이 아니어야만 테스트 성공
		만약 Null이라면 밑에 코드들은 실행되지 않음

	@AllArgsConstructor
		인스턴스 변수로 선언된 모든 것을 파라미터로 받는 생성자를 생성
		만약 @NonNull이 있다면 예외처리도 자동 생성
		ex)
			private String s1;
			private String s2;
			@NonNull
			private String s3;

			public 클래스명(String s1, String s2, String s3){
				if(t3 == null){
					throw new NullPointException();
				} else {
					this.t1 = t1;
					this.t2 = t2;
					this.t3 = t3;		
				}
			}

	@RequiredArgsConstructor
		@NonNull이나 final이 붙은 변수에 대한 생성자를 생성
		ex)
			private String s1;
			private final String s2;
			@NonNull
			private String s3;

			public 클래스명(String s2, @NonNull String s3){
				if(t3 == null){
					throw new NullPointException();
				} else {
					this.t2 = t2;
					this.t3 = t3;		
				}
			}
----------------------------------------------------------------------------------------------------------
try(Statement)
	Statement 자리에 close를 필요로 하는 인스턴스를 작성하면 자동으로 close() 한다.
	ex)
		try(Connection conn = 
			DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE",	
			"hr",
			"hr")){
			Log.info(conn);
		}catch(Exception e){
			fail(e.getMessage());
		}

		※ fail() : 테스트를 종료

<bean id="" class="" destroy-method="">
	객체를 생성하는 태그
	@Component, @Service 등과 동일
	id에는 객체명,
	class에는 패키지명.클래스명,
	destory-method에는 종료 시 사용할 메소드

	만일 여러 개의 자식 클래스가 있을 경우
	@을 여러개 사용하는게 아니라 <bean>으로 생성하되,
	id를 다르게 입력하고 @Autowired(required=false) @Qualifier("id")를 사용한다.
	

<constructor-arg ref="참조할 객체명"/>
----------------------------------------------------------------------------------------------------------
SQL문을 항상 인터페이스에 매핑
	SQL이 복잡하거나 길어지는 경우에는 @보다는 XML을 이용하는 방식을 더 선호하게 된다.
	MyBatis-Spring의 경우 Mapper 인터페이스와 XML을 동시에 이용할 수 있다.

	root-context.xml
		<mybatis-spring:scan base-package="패키지명"/> 추가

	1. XML을 이용할 경우
		src/main/resources/META-INF안에 폴더를 생성하고 xml 파일 생성
			여기서 폴더는 오류가 날 수 있으므로 하나씩 개별 생성
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 추가
		
		<mapper namespace="인터페이스가 있는 패키지와 인터페이스 이름">
		id에는 인터페이스에 있는 추상메소드의 이름을 쓴다.
		나머지는 model2 방식과 동일
		
		※ 스프링에서는 parameterType을 적지 않는다.
			(insert, update, delete는 id만 적으면 되는 것)

	2. 인터페이스
		@Select("쿼리문")
			이 부분에 쿼리문을 작성한다.
			SELECT면 @Select, DELETE면 @Delete
		public String 추상메소드명();
			【추상메소드가 실행되면 쿼리문이 실행되는 것】

		※ 사용은 컨트롤러에서 인터페이스만 객체화해서 사용

	※ 【추상메소드 당 쿼리문 하나】
----------------------------------------------------------------------------------------------------------
MVC model2를 사용하는 이유
	- 분업★★★
	- 유지보수
	- 페이지가 많기 때문에

(Spring MVC)Front-Controller 패턴
	            HandlerMapping
	        ①          ↕②        ③                      ④
	Client ↔ DispatcherServlet ↔ HandlerAdapter ↔ Controller
	        ⑥          ↕⑤
	              ViewResolver
	
	진행 순서(↑와 다름)
		1) 사용자의 모든 Request(URL)는 Front-Controller인 DispatcherServlet을 통해 처리한다(web.xml).
		2) HandlerMapping은 Request의 처리를 담당하는 컨트롤러를 찾기 위해 존재한다.
			@RequestMapping, @Controller가 적용된 것을 기준으로 판단하며,
			적절한 컨트롤러가 찾아졌다면 HandlerAdapter를 이용해서
			해당 컨트롤러를 동작시킨다.
			※ @XXXXMapping() : 요청이 매개변수에 있는 값이면 들어와라
			※ @Controller : 자동으로 스프링의 객체(Bean)로 등록된다.
			
			ex)
			- RequestMapping("/sample/*")
				sample로 시작하는 모든 애들은 이쪽으로 들어온다.

			- RequestMapping("")
				들어온 것 중에 sample뒤에 아무것도 없는 경우 들어온다.

			- RequestMapping(value="/basic", method={RequestMethod.GET, RequestMethod.POST})
				여러 개의 응답 방식을 사용할 경우 url은 value에 담아준다.

			※ RequestMapping은 GET과 POST 둘 다 사용할 경우만 쓴다.
				
			@GetMapping("/basicOnlyGet")
				GET방식으로 요청한 것만 들어온다.

			@PostMapping("/basicOnlyPost")
				POST방식으로 요청한 것만 들어온다.

		3) Controller는 Request를 처리하는 비지니스 로직을 작성하며,
			View에 전달해야 하는 데이터는 주로 Model 객체에 담아서 전달한다.
		4) ViewResolver는 Controller가 리턴한 결과를 
			어떤 View에서 처리하는 것이 좋을 지 해석하는 역할(servlet-context.xml)
		5) 만들어진 응답은 DispatcherServlet을 통해서 전송된다.

	※ 내가 생각한 순서
		사용자에게 요청(URL)이 들어오면 web.xml은 모든 URL을 DispatcherServlet으로 보내는데
		그 과정에서 servlet-context.xml에 가서 <context:component-scan>에 들어있는 패키지로 가서
		@Controller가 붙어있는 컨트롤러들을 객체화하고 @OOOMapping 중 어떤걸 실행할지 찾아서
			이 부분이 HandlerMapping
		실행 후 view와 model을 응답함
		그럼 다시 DispatcherServlet으로 돌아와서 컨트롤러에서 받은 view에 servlet-context.xml을 참고하여
		리턴값 앞에는 prefix, 뒤에는 suffix를 붙여서 어떤 jsp에 응답할지 알아낸 후 model을 넘겨준다.
			이 부분이 ViewResolver

		servlet-context.xml은 HandlerMapping과 ViewResolver 둘 다 사용하는 것

	
Spring MVC Controller 특징
	- HttpServletRequest, HttpServletResponse를 거의 사용할 필요가 없다.
	- 다양한 타입의 파라미터 처리, 다양한 타입의 리턴 타입 사용 가능
	- GET, POST 등 전송 방식에 대한 처리를 @으로 가능
	- 상속/인터페이스 방식 대신 @만으로도 설정 가능

Model(데이터 전달자)
	Model 객체는 【컨트롤러에서 생성된 데이터를 담아서 JSP에 전달하는 역할】
	반면 기본 자료형의 경우 파라미터로 선언하더라도 화면까지 전달되지 않는다.
		내가 만든 클래스 객체는 Model을 안붙여도 된다.
		자바에서 제공하는건 Model을 붙여야 한다.
			ex) String, int, ArrayList, [] 등
	Model은 Servlet의 request 내장 객체를 사용한다.

	@GetMapping("/ex01")
	public String ex01(SampleDTO dto){ }
		파라미터 타입에 따라 자동으로 매핑된다.

	@GetMapping("/ex02")
	public String ex02(@RequestParam("data1") String name, @RequestParam("data2") ing age, Model model){ }
		파라미터와 매개변수의 이름이 다를 경우 사용
		쿼리스트링에 key가 data1이면 name에, data2면 age에 담는다.
		그냥 name과 age를 사용할꺼면 @RequestParam()을 지운다.

		또는 매개변수로 변수와 객체를 받았을 경우,
			변수를 찾으면 객체부터 가서 변수를 찾기 때문에 오류가 발생해서
			여기 변수가 있다고 @RequestParam으로 알려주는 것
	

	@GetMapping("/ex03")
	public String ex03(@RequestParam("data") ArrayList<String> datas, Model model){ }
		쿼리스트링에 key가 data면 datas라는 ArrayList에 담는다.

	@GetMapping("/ex04")
	public String ex04(@RequestParam("data") String[] datas, Model model){ }
		쿼리스트링에 key가 data면 datas라는 String[]에 담는다.

	@GetMapping("/ex05")
	public void ex05(SampleDTO dto, @ModelAttribute("gender") String gender){ }
		참조형과 기본형을 같이 사용할 수 있다.
		※ 요청한 경로와 같은 경로로 리턴하는 경우 void를 사용해도 된다.
			다른 경로로 리턴하는 경우 리턴을 써준다.

	※ model.addAttribute(Object value)
		해당 객체의 클래스 타입에서 앞글자가 소문자로 바뀐 단어가 KEY값이 된다.

	※ @ModelAttribute("key")
		사용자가 만든 타입의 객체에 @ModelAttribute("key")를 붙인 경우 
		@의 매개변수인 key가 KEY값이 되고,
		붙이지 않은 경우 해당 타입의 앞글자를 소문자로 바꾼게 KEY값이 된다.

		@ModelAttribute("ttt") Test t로 쓴 경우
			ttt.OOO
		Test t만 쓸 경우
			test.OOO
----------------------------------------------------------------------------------------------------------
예외처리
	예외 발생 시 해당 예외 필드가 메모리에 할당된다.
	할당된 예외 필드의 주소값을 받을 객체가 필요하므로
	매개변수에 Exception타입의 e 객체를 선언해놓는다.

	@ExceptionHandler(Exception.class)
	public void temp(){}
		매개변수에 있는 예외가 발생되면 메소드를 실행한다.
		{예외1, 예외2}처럼 2개를 넣을 수도 있다.

	@ControllerAdvice
		해당 객체가 스프링의 컨트롤러에서 발생하는 【예외를 처리하는 존재임을 명시하는 것】

	【500메세지는】 Internal Server Error이므로 【@ExceptionHandler를 이용해서 처리가 가능】하지만
	【404메세지는】 잘못된 URL을 호출할 때 보이므로 【예외가 나지 않기 때문에 예외를 발생시켜야 한다.】
		404가 났을 때 예외가 발생하는 옵션
			<param-name>throwExceptionIfNoHandlerFound</param-name>
			<param-value>true</param-value>
				예외를 발생시킬꺼니? true/false

	@ResponseStatus(HttpStatus.NOT_FOUND)
		404는 자동으로 status가 넘어가지 않기 때문에
		【status를 직접 전달해주어야 한다.】
			하지 않으면 StackOverFlow가 뜬다.

	만들어둔 예외처리를 다른 프로젝트에서 사용할 경우
		web.xml, root-context.xml, src/java/main의 exception 패키지를 복붙한다.
----------------------------------------------------------------------------------------------------------
스프링 MVC 프로젝트의 기본 구성
	스프링 MVC에서 어떤 단계를 거쳐서 실행되는 지를 이해해야
	문제 발생 시 빠른 대처와 대안을 찾을 수 있다.

	3-tire방식
		     View	          Java            DB
		Presentation ↔ Business ↔ Persistence
		      ①               ②             ③

		[Presentation Tier(화면 계층)]
			【화면에 보여주는 기술을 사용하는 영역】
			Servlet/JSP 혹은 스프링 MVC가 담당하는 영역이며 화면 구성이 이에 속한다.

		[Business Tier(비지니스 계층)]
			【순수한 비지니스 로직을 담고 있는 영역】
			클라이언트의 요구사항을 반영하는 영역
			OOOService와 같은 이름으로 구성한다.
			
			Presentation Tire와 Persistence Tire의 중간다리 역할
			예를 들어 상품 구매 시 포인트 적립을 한다면
			Persistence Tire의 설계는 '상품', ''회원으로 나누어 설계하지만
			Business Tire는 '상품', '회원'을 동시에 사용해서 하나의 로직으로 처리하게 된다.
			즉, 하나의 트랜잭션에 여러 개의 쿼리문이 필요하기 때문에
				메소드를 여러개 사용해야 하지만
				Service에 사용해야 할 메소드들을 넣어놓고
				Service 한 번만 사용하여 메소드를 여러개 사용하는 효과를 내는 것
				【컨트롤러에서는 mapper가 아닌 service만 사용한다.】

			인터페이스 없이 클래스만 만들 수 있지만
				【재사용을 하기 위해】 인터페이스를 연결해서 사용한다.

		[Persistence Tire(영속 계층 or 데이터 계층)]
			【데이터의 보관 방식과 사용에 대한 영역】
			일반적으로 DB를 많이 이용하지만,
				상황에 따라 네트워크 호출 or 원격 호출 등의 기술이 접목된다.

		각 영역은 독립적으로 설계되어 쉽게 교체가 가능하다.
		각 연결 부위는 인터페이스를 이용해서 설계하는 것이 일반적인 구성이다.
----------------------------------------------------------------------------------------------------------
Naming Convention(명명 규칙)
	config : 		프로젝트와 관련된 설정 클래스들을 보관하는 패키지
	controller :	스프링 MVC의 Controller들을 보관하는 패키지
	service : 		스프링 Service 인터페이스와 클래스를 보관하는 패키지
	domain : 		VO, DTO를 보관하는 패키지
				테이블의 컬럼이랑 필드가 일치하면 VO
				그 외에는 DTO
				VO와 DTO는 의존성 주입을 하지 않기 때문에
				@Component를 쓰지 않는다.
	persistence : 	Mybatis Mapper 인터페이스 패키지
	exception : 	웹 관련 예외처리 패키지
	aop : 		AOP 관련 패키지
	security : 	Security 관련 패키지(자동 로그인, 세션 종료 등)
	util : 		각종 유틸리티 관련 패키지
----------------------------------------------------------------------------------------------------------
PK값을 미리 SQL을 통해서 처리하는 방식
	SQL을 한 번 더 실행하는 부담이 있기는 하지만
	자동으로 추가되는 PK값을 확인해야 하는 상황에서는 유용하게 사용될 수 있다.

	예시)
	<insert id="insertSelectKey_bno">
		<selectKey keyProperty="bno" order="BEFORE" resultType="Long">
			SELECT SEQ_BOARD.NEXTVAL FROM DUAL
		</selectKey>		
			※ Key Property : 가져온 key값을 넣을 필드명
			※ order="BEFORE" : 가장 먼저 실행한다는 의미
		※ 여기까지만 먼저 실행되고 bno에 결과값이 들어간 후 다음 SQL이 실행되는 것★
		INSERT INTO TBL_BOARD(BNO, TITLE, CONTENT, WRITER)
		VALUES(#{bno}, #{title}, #{content}, #{writer})
	</insert>
----------------------------------------------------------------------------------------------------------
스네이크표기법(_)를 카멜표기법으로 바꿔주는 라이브러리
	root-context.xml의 <bean id="sqlSessionFactory">안에
	<property name="configuration">
		<bean class="org.apache.ibatis.session.Configuration">
			<property name="mapUnderscoreToCamelCase" value="true"/>
		</bean>
	</property>
----------------------------------------------------------------------------------------------------------
Tomcat 없이 컨트롤러 테스트 하는 방법
	【WebApplicationContext가 항상 가장 먼저 메모리에 할당된다.】
		할당되지 않으면 아무것도 할 수 없다.
	톰캣을 사용하면 WebApplicationContext가 설정되지만,
	톰캣을 사용하지 않는 경우 직접 설정해야 한다.

	@WebAppConfiguration : Servlet의 ServletContext를 이용한다.
	@ContextConfiguration({
		"file:src/main/webapp/WEB-INF/spring/root-context.xml",
		"file:src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml"
	})

MockMVC
	가짜 MVC
	마치 브라우저에서 사용하는 것처럼 만들어서 Controller를 실행
	【주입을 받지 않고 WebApplicationContext를 통해 빌드한다.】

	빌드)	
	@Setter(onMethod_ = @Autowired)
	private WebApplicationContext wad;

	private MockMVC mockMvc;
	@Before // 가장 먼저 실행
	public void setUp(){
		this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
	}

	사용1, Model로 넘긴 경우)
	mockMvc.perform(MockMvcRequestBuilders.get("/board/list")
			.param(key, value)
				//컨트롤러로 파라미터를 넘겨야 하는 경우 사용
		.andReturn()
		.getModelAndView() // 모델에 리턴받은 데이터를 맵 형식으로 확인
		.getModelMap());

	사용2, Flash로 넘긴 경우)
	mockMvc.perform(MockMvcRequestBuilders.update("/board/update")
			.param(key, value)
		.andReturn()
		.getFlashMap()); // Flash를 사용했으면 여기서도 FlashMap을 사용한다.

	※ 만약 오류가 발생할 경우
		pom.xml에서
		94번 줄에 <artifactId>javax.servlet-api</artifactId>
		95번 줄에 <version>3.1.0</version>
----------------------------------------------------------------------------------------------------------
Redirect로 응답
	컨트롤러에서 return에 "rediect:/경로'
		'rediect:' == response.sendRedirect()
		default는 forward 방식

	Redirect 방식은 request를 초기화하므로
		Model 객체의 addAttribute()가 아닌,
		RedirectAttributes 객체의 addFlashAttribute()를 사용한다.

	Flash
		Redirect는 request가 초기화 되기 때문에
		페이지를 이동할 때 Session의 Flash 영역에 잠시 데이터를 맡겨두고
		페이지 이동 후 꺼내오는 방식이다. (데이터를 꺼내면 Flash 영역은 비어있음)
		단, Flash 영역에는 남용을 방지하기 위해서
			addFlashAttribute()는 한 번만 사용할 수 있는데
			다른 데이터를 넘겨야 하는 경우 쿼리스트링 방식을 이용해야 하는데
			그 때 RedirectAttributes 객체의 addAttribute()를 사용하면
			자동으로 쿼리스트링에 붙게된다.
----------------------------------------------------------------------------------------------------------
게시판에서 글 등록 시 한글이 깨지는 경우
	web.xml에 밑에 코드를 추가한다.
	<filter>
		<filter-name>encoding</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>   
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
   
	<filter-mapping>
		<filter-name>encoding</filter-name>
		<servlet-name>appServlet</servlet-name>
	</filter-mapping>	
----------------------------------------------------------------------------------------------------------
화면 페이징 처리
	ORDER BY가 아닌 인덱스를 사용하면 정렬을 생략할 수 있다.
		인덱스가 이미 정렬된 구조이기 때문이다.
		예를 들어 테이블이 하나의 책이라면,
			인덱스는 각 페이지 번호를 의미한다.
		인덱스를 통해서 원하는 내용을 위에서부터 혹은 밑에서부터 찾아나가는 것을 scan이라고 한다.

	Hint
		SELECT문에 실행하고 싶은 계획을 전달할 때 사용하는 문법
		/*+ Hint(테이블명 PK명) */
			【()안에 쉼표(,)는 사용하지 않는다.】
	
		주의)
		잘못 작성되어도 실행할 때에는 무시되며 별도의 오류가 발생하지 않는다.

	※ ROWID : 행 마다 부여되는 주소값

	예시)
	<select id="getListWithPaging" resultType="com.koreait.domain.BoardVO">
		SELECT BNO, TITLE, CONTENT, WRITER
			//여기서 *을 안쓰고 컬럼명을 쓴 이유는 
				*보다 컬럼명을 쓰는게 속도가 훨씬 빠르기 때문이다.
		FROM
			(SELECT /*+ INDEX_DESC(TBL_BOARD PK_BNO) */
				ROWNUM RN, BNO, TITLE, CONTENT, WRITER
				FROM TBL_BOARD WHERE ROWNUM <![CDATA[<=]]> #{pageNum} * #{amount})
		WHERE RN <![CDATA[>]]> (#{pageNum} - 1) * #{amount}
	</select>

	※ Criteria : 검색의 기준
	※ Math.ceil() : 올림(3.1이면 4)	
----------------------------------------------------------------------------------------------------------
MyBatis의 동적 태그
	<if>
		<if test="">
			쿼리문
			//조건이 참이어야만 쿼리문이 실행된다.
		</if>
		

	<choose>
		<choose>
			<when test="">
				쿼리문
				//조건이 참일 경우 실행				
			</when>
			<otherwise>
				쿼리문
				//모든 <when>이 거짓일 경우 실행
			</otherwise>
		</choose>

	<where>
		<where>
			<if test="">
				쿼리문
			</if>
			//<where>안에 쿼리문이 있을 경우 WHERE절을 생성,
				쿼리문이 없을 경우 WHERE절을 생성하지 않는다.
				여기서는 <if>가 참이면 <where>가 WHERE를 만들어서 쿼리문을 붙이고,
				<if>가 거짓이면 <where>가 WHERE절을 만들지 않는다.
		</where>

	<trim>
		prefixOverrides, suffixOverrides
			쿼리문 맨 앞(맨 뒤)에 필요하면 넣어주고 필요없으면 빼주는 것
			앞(뒤)의 조건식의 유무에 따라 결정된다.
			prefix(suffix) / Overrides로 나눠서
				일단 만들고 조건식의 유무에 따라 빼는 형식으로 생각해도 된다.

		prefix : 앞에 무조건 붙여라.
		suffix : 뒤에 무조건 붙여라.

		예시)
		SELECT * FROM TBL_BOARD
			<where>
				<if test="bno != null">
					BNO = #{bno}
				</if>
				<trim prefixOverrides="AND">
					ROWNUM = 1
				</trim>
			</where>
			bno가 null일 경우
				SELECT * FROM TBL_BOARD WHERE ROWNUM = 1
			bno가 null이 아닐 경우
				SELECT * FROM TBL_BOARD WHERE BNO = #{bno} AND ROWNUM = 1				
			
	<foreach>	
		List, 배열, Map 등을 이용해서 반복
		<foreach item="" index="" collection="">
			item은 value값이 담길 변수
			index는 현재 index(Map이면 key)
			collection은 List, 배열, Map등이 담길 변수
		</foreach>

	※ | : 파이프 연산자 혹은 Concatenation(연결)
		하나의 문자열로 연결해주는 역할

	※ split()에 구분점을 전달하지 않으면 문자 하나하나가 분리된다.
		String temp = "CAT";
		temp.split(); 하면 C, A, T가 담긴 3칸짜리 배열

	※ 서브쿼리를 ()로 묶는 이유는 가독성 때문, 다른 이유는 없다.
----------------------------------------------------------------------------------------------------------
XML에서 쿼리문을 재사용
	<sql id="">
		재사용 할 쿼리문
	</sql>으로 만들고
	사용하는 곳에서 <include refid="id"/>를 쓴다.
----------------------------------------------------------------------------------------------------------
UriComponentsBuilder
	쿼리스트링을 만들어주는 라이브러리
	여러 개의 파라미터들을 연결하여 URL 형태로 만들어주는 기능
	
	예시)
	public String getListLink(){
		UriComponentBuilder builder = UriComponentsBuilder.fromPath("")
			.queryParam("key", value)
			//쿼리스트링에 추가할 key와 value

		return builder.toUriString();
	}

	사용)
	?pageNum=${pageMaker.cri.getListLink()}&amount=${pageMaker.cri.getListLink()}를
	${pageMaker.cri.getListLink()}로 사용할 수 있다.

	※ 맨 앞에 ?가 반드시 붙기 때문에
		다른 쿼리스트링이 있다면 만들어둔 UriComponentsBuilder 뒤에 &를 하고 붙여준다.
----------------------------------------------------------------------------------------------------------
@Param("Key")
	매개변수로 적은 key에 담겨서 이동한다.

	예시)
		@Param("cri") Criteria cri

	Mybatis는 mapper.xml에 두 개 이상의 데이터를 파라미터로 전달하기 위해서는
	① 별도의 객체를 구성하거나,
	② Map을 이용하거나,
	③ @Param을 이용한다.
----------------------------------------------------------------------------------------------------------
URL
	사용자의 요청과 그에 맞는 응답을 【주소】로 나타낸 부분
	【페이지로 나타내진다.】

URI
	사용자의 요청을 대표하는 【데이터】 혹은 응답에 대한 【데이터】를 나타낸 부분.
	【데이터로 나타내진다.】

REST
	Representational State Transfer
	【"하나의 URI는 하나의 고유한 리소스를 대표하도록 설계된다."】
	
	REST로 설계하는 이유
		1. 데이터 통신에 제약이 없다.
		2. 데이터 소켓 경량화
			※ 소켓 : 데이터가 담겨있는 공간
		3. 다른 서버끼리도 데이터를 주고 받을 수 있다.

	@RequestMapping("/replies/")
		/replies/*과 동일하다.

	@RestController
		각 메소드의 【리턴은 ViewResolver로 보내지 않는다.】
			servlet-context.xml로 가지 않기 때문에
			suffix인 .jsp가 붙지 않아서 【return을 그대로 리턴한다.】
		
		만약 servlet-context.xml로도 가야하고, 
		return도 그대로 리턴해야 하는 경우
		@RestController가 아닌 @Controller를 사용하고,
		return을 그대로 사용해야 하는 메소드 위에
		@ResponseBody를 붙여주면 해당 메소드만
		servlet-context.xml로 가지 않는다.

	consumes
		【Ajax를 통해 전달받은 데이터의 타입】
		contentType
			Ajax에서 data:를 통해 데이터를 전송하는 경우
			contentType에는 그 데이터의 타입을 적는다.

	produces
		【Ajax의 success의 result로 전달할 데이터의 타입】
		dataType
			default는 TEXT

		produces={MediaType.TEXT_PLAIN_VALUE}
			TEXT로 응답하겠다.
		produces={MediaType.APPLICATION_JSON_UTF8_VALUE, MediaType.APPLICATION_XML_VALUE}
			JSON, XML로 응답하겠다.

	ResponsEntity<>(응답데이터, 상태)
		【응답 데이터는 Ajax의 success의 result로 전달할 데이터】
		응답데이터, 서버의 상태 등을 담을 수 있는 타입
		제네릭(<>)으로 선언되어 있기 때문에 제네릭에 적은 타입을 받는 생성자가 자동 생성된다.

		※ 상태
			HttpStatus.INTERNAL_SERVER_ERROR
				상태 : 500
			HttpStatus.OK
				상태 : 200

		@RequestBody
			JSON데이터를 변환하도록 지정한다.
			
			예시)
			@RequestBody ReplyVO reply
				JSON으로 받은 데이터를 ReplyVO타입으로 변환 후
				reply에 넣는다.

		@OOOMapping의 value에 {}는 변수의 선언
			예를 들어 외부에서 bno를 전달하면
			{bno}에 담긴다.

		@PathVariable("key")
			{}에 담겨있는 값을 가져온다.

			예시)
			@PathVariable("bno") Long bno
				{bno}에 담긴 값을 Long bno에 넣는다.

		PUT과 PATCH
			PUT
				자원 전체 수정
				【자원 내 모든 필드를 전달해야 함】
					일부만 전달할 경우 전달되지 않은 필드는
					모두 초기화 처리가 된다.

			PATCH
				자원 일부 수정
				수정할 필드만 전송

	JACKSON 라이브러리 추가하기
		pom.xml에서 <!--Logging --> 위에 붙여넣기
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.9.6</version>
		</dependency>
	      
		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.9.6</version>
		</dependency>
      
		<dependency>
			<groupId>com.google.code.gson</groupId>
			<artifactId>gson</artifactId>
			<version>2.8.2</version>
		</dependency>
		
	※ RestController 테스트 하기
		크롬 > 왼쪽 상단에 앱 > 웹 스토어 > talend api tester
		> 크롬에 추가 > 실행

	※ XML로 결과가 나왔을 때 url 마지막에 .json을 붙여주면 JSON 타입으로 변경된다.
		default가 xml인 것

	※ value가 같아도 Ajax의 적는 type에 따라 알맞는 @Mapping이 실행된다.

	※ value에 적는게 하나의 고유한 리소스를 대표하는 하나의 URI

댓글 등록
   @PostMapping(value="/new", consumes="application/json", produces={MediaType.TEXT_PLAIN_VALUE})
   public ResponseEntity<String> create(@RequestBody ReplyVO reply){
      	return service.register(reply) == 1 ? new ResponseEntity<String>("success", HttpStatus.OK) :
         	new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);	
   }

댓글 목록
   @GetMapping(value="/pages/{bno}/{page}", produces={MediaType.APPLICATION_XML_VALUE,
      	MediaType.APPLICATION_JSON_UTF8_VALUE})
   public ResponseEntity<List<ReplyVO>> getList(@PathVariable("bno") Long bno, @PathVariable("page") int page){
      	Criteria cri = new Criteria(page, 10);
      	return new ResponseEntity<List<ReplyVO>>(service.getListWithPaging(cri, bno), HttpStatus.OK);
   }

댓글 조회
   @GetMapping(value="/{rno}", produces={MediaType.APPLICATION_XML_VALUE,
      	MediaType.APPLICATION_JSON_UTF8_VALUE})   
   public ResponseEntity<ReplyVO> get(@PathVariable("rno") Long rno){
      	return new ResponseEntity<ReplyVO>(service.get(rno), HttpStatus.OK);
   }

댓글 수정
   @RequestMapping(method={RequestMethod.PUT, RequestMethod.PATCH}, value="/{rno}",
      	consumes="application/json", produces={MediaType.TEXT_PLAIN_VALUE})
   public ResponseEntity<String> modify(@RequestBody ReplyVO reply, @PathVariable("rno") Long rno){
      	reply.setRno(rno);
	return service.modify(reply) == 1 ? new ResponseEntity<String>("success", HttpStatus.OK) :
         	new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
   }

댓글 삭제
   @DelelteMapping(value="/{rno}", produces={MediaType.TEXT_PLAIN_VALUE})
   public ResponseEntity<String> remove(@PathVariable("rno") Long rno){
	return service.remove(rno) == 1 ? new ResponseEntity<String>("success", HttpStatus.OK) :
         	new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
   }
----------------------------------------------------------------------------------------------------------
Javascript의 모듈화
	함수들을 하나의 모듈처럼 【부품으로 구성하는 것】을 의미한다.
	화면 내에서 Javascript 처리를 하다 보면 이벤트 처리와 DOM, Ajax 처리 등이
	복잡하게 섞여서 유지보수가 힘들다.
	따라서 Javascript를 하나의 모듈처럼 구성하여 사용한다.

	※ JSON에서 오류가 나면 Javascript를 확인해본다.
	※ 함수의 매개변수에 callback, error가 있어도 반드시 받아야하는건 아니다.
		대신 error만 넣을 경우 callback에 들어가니 순서에 맞게 넣어준다.

JSON.stringify()
	【JSON의 모든 Key와 Value가 ""로 감싸있지 않으면 자동으로 감싸준다.】
	정수나 실수는 알아서 판단해서 붙지 않고, 날짜는 붙는다.
	JSON을 쓸 수 있는 라이브러리를 추가하면 생성된다.

$.get(url, success(){}).fail(error(){});
	$.getJSON과 동일하다.
	get 대신 다른 전송 방식을 쓸 수 있다.
	$.ajax()의 error는 fail에 넣는다.

	【단 url의 마지막에 ".json"을 붙여줘야한다.】

매개변수
	Ajax에서 매개변수에 JSON 타입으로 넣을 경우
		Key값으로 Value를 꺼내서 사용할 수 있다.
	
	Ajax에서 JSON 타입으로 값을 넣을 때
		Key는 반드시 필드명과 일치시키고,
			※ 일치시키지 않을 경우 자동으로 매핑이 되지 않는다.
		함수에서 매개변수의 명칭은 자유롭게 짓는다.
			
var page = reply.page || 1
	reply.page를 넣거나,
	reply.page가 비어있을 경우 1을 넣는다.

※ Ajax에서 넘길 값이 하나라면 굳이 JSON 타입으로 넘기지 않아도 된다.

※ 자주하는 실수 : 꼭 함수를 만들었다면 return을 해주자.
----------------------------------------------------------------------------------------------------------
on("이벤트", function(){})
	Node.js에서도 쓰는 방식이니 최대한 이걸로 만들기
	
<textarea>
	<textarea>에 미리 입력한 값을 받아올 때는 text(), val()로 받을 수 있지만,
	사용자가 입력한 값을 받아올 때는 val()로만 받을 수 있다.
	렌더링이 끝나고 난 뒤 입력을 했으면 val()
	렌더링 전에 입력이 되었던 값이면 text()를 사용한다.
		※ 렌더링 : 브라우저 로딩이 끝나고 난 뒤

data 속성
	【태그에 원하는 value를 저장시키기 위해서 사용한다.】
	data-변수명="value"로 작성하며,
	jQuery에서 해당 태그객체.data("변수명")으로 value를 가져와 사용할 수 있다.
	만약 value를 수정하고 싶다면 해당 태그객체.data("변수명", "새로운 값");

	예시)
	<li class="test" data-rno=list[i].rno></li>
	$(".test").data("rno")로 list[i].rno를 가져올 수 있는 것

var finishTemp = $(".finish");
	finishTemp는 jQuery를 대입했기 때문에 jQuery지만,
	안에 있는 finishTemp[0], finishTemp[1], ...은 Javascript이다.
	각각의 요소들은 $()안에 들어갔다 온게 아니기 때문이다.

이벤트 위임
	처음부터 없던 코드를 자바스크립트로 붙이면,
	이벤트 함수가 새로운 코드를 인식하지 못하여 사용이 불가능하다.
	이럴 때에는 처음부터 있는 부모 태그에 이벤트를 주고,
	그 자식 태그로 들어올 선택자를 작성하여 이벤트를 위임한다.
	
	부모가 자식이 아직 없을 경우 이벤트를 가지고 있다가
	자식이 생긴다면 이벤트를 자식에게 주는 것
		상속이 아니라 완전히 주는 것이라서
		넘겨주는 순간 부모에는 이벤트가 사라진다.

	예시)
	$("부모").on("click", "자식", function(e){
		이벤트
	})

재귀함수
	【내가 나를 호출하는 것】
	단, 나를 호출한 순간 그 밑에 코드는 실행되지 않는다.	

	예시)
		function test(){
			// 나를 호출한 순간 ... 들은 실행되지 않는다.
			test();
			...
			...
		}
----------------------------------------------------------------------------------------------------------
AOP
	Aspect-Oriented-Programming
	관점 지향 프로그래밍
	관점이란 개발에 있어서, 관심사(concern)를 의미한다.
	【관심사는 개발 시 필요한 것들을 생각하는 일】이며, 아래와 같다.

	- 파라미터가 잘 전달되었는지?
	- 적절한 권한을 가진 사용자가 작업하고 있는지?
	- 이 로직에서 발생할 수 있는 모든 예외를 처리하기

	핵심 로직은 아니지만 반복적으로 개발에 필요한 관심사들이다.
	따라서 AOP는 이러한 것들을 모듈로 분리하여 작성하고
	핵심 비지니스 로직만을 작성하도록 한다.

	예시)
	나눗셈 프로그램 개발 시 두 개의 숫자를 나누는 것은 핵심로직(종단관심사),
	0으로 나누는지 체크하는 것을 주변로직(횡단관심사)이라고 한다.

	즉, 【반복적으로 나타나는 횡단관심사를
	모듈로 분리한 후 적절한 곳에 로직을 주입하는 것】
	스프링에서는 별도의 복잡한 설정 없이
	간편하게 AOP의 기능들을 구현할 수 있기 때문에 중요한 특징 중 하나이다.

	AOP를 사용할 수 있을 때
		1. Around(모든 구역)
		2. Before(메소드 시작 직후)
		3. After(리턴이 나오기 직전)
		4. AfterReturning(After 이후 리턴 이전)
		5. AfterThrowing(메소드에서 예외 발생 종료 후)

	@Aspect
		【AOP라고 스프링에게 알려주는 것】

	AOP를 사용하기 위해서는 종단관심사에 Proxy설정이 되어야 한다.
		※ Proxy : 【횡단관심사와 종단관심사를 연결시켜주는 역할】
		※ Proxy설정 : root-context.xml에 
				<aop:aspectj-autoproxy></aop:aspectj-autoproxy> 추가

		※ pointcut : 모듈(횡단관심사)이 Proxy 설정이 되어 있는 주객체(종단관심사)에게
				【언제 결합해야 되는지를 알려준다.】
		※ JoinPoint : 【결합되는 지점】
				주객체에 있는 종단관심사가 호출되면
				【pointcut에 작성된 메소드의 전체 정보를 가지고 올 수 있는 객체】

	AOP 문법
		@Before("①execution(②* com.koreait.service.SampleService③*.④*⑤(..))"){ }
			①은 AspectJ의 표현식
			②는 모든 접근제어자
			③은 SampleService가 붙은 모든 클래스
			④는 SampleService*에 들어있는 모든 메소드
			⑤는 매개변수가 0개 이상(..)이라는 뜻
			
	<context:annotation-config></context:annotation-config>
		root-context.xml에서 namespaces에 aop, context를 체크하고,
		위에 코드를 작성하면 【이미 등록된 Bean에 대해서만 Annotation을 활성화 한다.】

	args(매개변수1, 매개변수2, ...)
		호출된 종단관심사의 매개변수를 횡단관심사로 전달받을 때에는
		매개변수의 개수와 타입에 맞게 작성해주어야 하며,
		args에 해당 매개변수의 이름을 동일하게 작성해주어야 한다.
	
		예시)
		@Before("execution(* com.koreait.service.SampleService*.doAdd(String, String)) && args(str1, str2)")
		public void logBefore(String str1, String str2){ }
			doAdd라는 메소드 중 매개변수를 (String, String)으로 받는 애가 들어왔을 때
			매개변수를 str1과 str2에 넣어라.

	@AfterThrowing
		예외를 처리할 때 사용한다.

		예시)
		@AfterThrowing(pointcut="execution()", throwing="매개변수로 받은 exception")
		public void logException(Exception exception){ }
			
		※ 여러 개의 프로퍼티를 줄 경우 pointcut을 명시해야 한다.

	@Around에서 메소드를 실행하면 jsp로 보내는게 아니라 이쪽으로 오기 때문에
		이쪽에서 다시 메소드를 실행해주어야 한다.

		※ ProceedingJoinPoint : @Around 했을 경우 해당 메소드에 대한 모든 정보를 가지고 있는 객체
		※ ProceedingJoinPoint객체.proceed() : 실행한 메소드의 리턴값 호출
						【이걸 안하면 메소드의 정보만 가져오고 실행을 안한 것】

		예시)
		@Around("execution(* com.koreait.service.SampleService*.*(..))")
		public Object logTime(ProceedingJoinPoint pjp) {
			Long start = System.currentTimeMillis();
			
			log.info("핵심 로직 : "+pjp.getTarget());
			//Object[]로 리턴하기 때문에 Arrays.toString()을 사용
			log.info("파라미터 : "+Arrays.toString(pjp.getArgs()));
			
			Object result = null;
		
			try {
				result = pjp.proceed();
			} catch (Throwable e) {
				e.printStackTrace();
			}
		
			Long end = System.currentTimeMillis();
			log.info("걸린 시간 : " + (end-start));
			return result;
		}
----------------------------------------------------------------------------------------------------------
트랜잭션
	하나의 쿼리만 사용한다면 예외 발생 후 DB에는 변화가 없다.
	하지만 여러 개의 쿼리(하나의 트랜잭션)을 순차적으로 실행 후 문제 발생 시
	성공한 쿼리문만 반영되어 다시 직접 복구해야하는 문제가 발생한다.
	이러한 문제를 막기 위해 스프링에서는
	【@Transactional을 사용하여 한 개의 트랜잭션에 문제 발생 시
	롤백을 통해 전체 트랜잭션이 모두 DB에 반영되지 못하도록 막아준다.】
	
	하나의 메소드에서 쿼리 여러 개가 순차적으로 진행되는 경우 사용한다.
	전혀 관계없는 쿼리끼리 있을 경우 사용할 필요는 없다.
----------------------------------------------------------------------------------------------------------
웹 디자이너 : 	포토샵, 일러스트 파일로 웹 개발에 필요한 요소 디자인
			레이아웃, 폰트 등을 결정하는 것
퍼블리셔 : 	한국에만 있는 직종
			프론트 엔드 개발자를 도와주는 역할
프론트 엔드 : 	백에서 요청한 뷰를 알맞게 응답
		퍼블리셔가 Node를 하면 프론트 엔드
백엔드 : 		REST
풀스택 : 		백 + 프론트 + 엔드

※ 엔드 : 서버

※ 【REST : 데이터를 파라미터로 전달하는게 아니라 JSON 파일로 전달하는 것】

※ 프론트에 문제가 생기면 프론트 엔드가 아니라 퍼블리셔에게 가야한다.

프로젝트 순서
	1. 웹 디자인 포토샵 파일 완성
	2. 프론트 엔드 개발자가 각 요소를 디자인에서 분리
	3. 백 엔드 개발자가 해당 이미지를 사용

	클라이언트 → 백 단 서버 → 연산, 동적데이터 처리
	→ 응답 → 프론트 요청 → 프론트 응답 → 백 단 응답

※ 렌더링 : 브라우저에서 해석해서 뿌려주는 것
----------------------------------------------------------------------------------------------------------
※ jsp에서 EL문을 사용할 때 getter 대신 필드명을 사용할 수 있다.
	${board.getBno()} == ${board.bno}

※ jsp에서 톰캣의 모듈이 "/"가 아닌 "/board"라면
	<script src="/resources/assets/js/jquery.min.js"/>를
	<script src="/board/resources/assets/js/jquery.min.js"/>로 수정해야 한다.

※ 컨트롤러에서 동일한 코드를 다른 곳에서도 사용할 경우
	새로 만드는 것이 아니라 경로에 추가한다.
	@GetMapping({"/list", "modify"})
	
※ 인라인으로 속성을 적용하면 미디어쿼리에서 적용이 안되는 경우가 생기니까 <style>에 적용하기

※ 컨트롤러에 있는 클래스 타입의 매개변수는 생성자를 통해서 파라미터 값으로 초기화 한다.
	만약 전달받은 파라미터 값에 매핑되는 생성자가 없다면 값을 전달받을 수 없다.
	따라서 【반드시 해당 객체의 생성자에 전달할 필드명과 일치하도록 설정해준다.】
	
	예시)
	rttr.addFlashAttribute("cri", cri) (x)
	rttr.addFlashAttribute("pageNum", pageNum) (o)
	rttr.addFlashAttribute("amount", amount) (o)

※ javascript:void(0) : 디자인만 살려두고 기능은 없애주는 것

※ 조건식에 val()을 쓰면 값을 불러오는게 아니라 값이 있냐 없냐가 된다.

※ QR 만드는 법
	첫번째 방법)
		https://ko.qr-code-generator.com/?ut_source=
		google_c&ut_medium=cpc&ut_campaign=&ut_content=&ut_term
		=%2Bqr%20%2B%EB%A7%8C%EB%93%A4%EA%B8%B0_b&gclid
		=CjwKCAjw-e2EBhAhEiwAJI5jgxXRBXRSgycN6cBl5WpgSpo
		WarMIMghhgEGmFK0Vi6Bb3hKa44jZzBoCINoQAvD_BwE
		가서 URL 입력하거나

	두번째 방법)
		https://www.miricanvas.com/ 가서 만들기 들어가서 더보기에 QR코드 URL 입력

※ 전자정부표준프레임워크(egov)
	정부 공공 프로젝트 등 상용화 혹은 서비스해야할 상품을 제작할 때
	표준 라이브러리만 제공해준다.

	스프링 기반으로 만들어져 있으며,
	STS와 같이 이클립스의 확장 버전이라고 생각하면 된다.

	사용하는 이유
		전자정부 프레임워크 등장 이전에는 특정 업체의 프레임워크로 만들어
		중소기업이 뛰어들기 힘들었다.
		정부는 비용을 더 절감하고 업체 입장에서는 더 많은 기회가 생기는 이점이 있다.

※ @RunWith(SpringRunner.class)
	SpringJUnitClassRunner의 자식이며,
	4.3버전 이상부터 사용 가능한 확장판이다.

※ ROWID는 순서가 없어서 가져올 때는 Hint에서 INDEX_DESC 등으로 순서를 정해주는 것

※ fa-OOO
	Font-Awesome
	【웹 아이콘 폰트를 모아놓은 라이브러리】
	아이콘은 이미지가 아닌 폰트이기 때문에 CSS를 적용할 수 있다.
	
	사용
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/
			font-awesome/4.7.0/css/font-awesome.min.css">
		<head>안에 추가하고,
		class에 fa-OOO를 넣어주기

	아이콘 목록
		https://fontawesome.com/icons?d=gallery&p=2

※ Controller에서 result로 한글을 보낼 때 깨질 경우
	produces="text/plain; charset=utf-8
	produces="application/text; charset=utf-8"로 설정하면 된다.

※ Test에서 Log가 4줄만 나오는 경우 
	src/test/resources에 Log4j.xml에서
	맨 아래쪽에 info가 아닌 warn으로 되어있는지 확인한다.

※ jQuery를 사용했던 이유
	웹 표준으로 개발되던 시대가 아니었을 때에는
	개발자가 버전별로 다양한 언어들을 공부해야 했다.
	그렇기 때문에 웹 표준을 정해놓으면 개발자들이 편하게 개발할 수 있는 상태였다.
	바로 이 때 jQuery를 만든 회사에서 JS의 표준화
	즉, 통일성을 주기 위해서 홍보를 하였고,
	jQuery 개발자가 대폭 늘어나며, 거의 모든 프로젝트에서 사용되었다.
	하지만 지금은 거의 대부분의 브라우저가 W3C에 의해 표준화된 웹 표준을 사용하기 때문에
	jQuery의 목적성을 잃어 가고 있다.
		