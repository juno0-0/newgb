프레임워크
	【뼈대나 근간을 이루는 코드들의 묶음】
	프로그램의 기본 흐름이나 구조를 정하고 모든 팀원이 이 구조에 
	자신의 코드를 추가하는 방식으로 개발하게 된다.

	프레임워크와 라이브러리의 차이
		- 프레임워크
			【제어의 주체가 프레임워크】이고,
			【프레임워크 안의 여러 기능들을 가져다 사용하는 방식】
			만약 수정해야할 경우에는 도구들을 사용해서 수정 및 추가가 가능

		- 라이브러리
			【제어의 주체가 개발자】이고,
			【핵심 로직에서 필요한 부분들만 가져다 사용하는 방식】

	장점
		회사 입장 : 일정한 품질이 보장
		개발자 입장 : 완성된 구조에 자신의 코드를 넣기 때문에 개발 시간을 단축
----------------------------------------------------------------------------------------------------------
스프링 프레임워크
	【경량 프레임워크(light-weight)】★★★
		특정 기능을 위주로 간단한 jar파일 등을 이용해서 모든 개발이 가능하도록 구성
	
		※ 예전 프레임워크들은 다양한 경우의 수를 처리하기 위해
			다양한 기능을 가지도록 만들다 보니 하나의 기능을 위해 사용하더라도
			모든 기능을 사용해야해서 너무 복잡하고 방대했기 때문에,
			전체를 이해하고 개발하기 어려웠다.

	장점
		- 복잡하지 않다.
		- 프로젝트 전체 구조를 설계할 때 유용하다.
		- 다른 프레임워크들을 포용한다.
			여러 프레임워크를 혼용해서 사용 가능(접착성)
		- 생산성이 올라가고 개발도구를 지원한다.

	특징
		- POJO 기반의 구성
			Plain Old Java Object
			오래된 방식의 간단한 자바 객체라는 의미
			자바 코드에서 객체를 구성하는 방식을
			스프링 프레임워크에서 그대로 사용할 수 있다는 말.
			【즉, 자바를 쓸 수 있다는 말】

		- 의존성 주입(DI)을 통한 객체 간의 관계 구성
			의존성(Dependency)
				【하나의 객체가 다른 객체 없이 제대로 된 역할을 할 수 없다는 것】
				의존성과 결합성은 비례한다.
				ex) ⓐ →→→→→→ ⓑ
					a객체에서 b객체를 직접 생성
					a가 b에 의존한다 혹은 a와 b의 결합성이 단단하다

			주입(Injection)
				【외부에서 밀어 넣는 것】
				주입을 받는 입장에서는 어떤 객체에 의존하든 자신의 역할은 변하지 않게 된다.
				ex) ⓐ →→→ ApplicationContext →→→ ⓑ
					a객체는 b객체가 필요하다는 신호만 보내고,
					b객체를 ApplicationContext가 주입한다.

			ApplicationContext★★★
				【필요한 객체들을 생성하고 주입해주는 역할】
				ApplicationContext가 있기 때문에 객체와 객체를 분리해서 생성하고,
				객체들을 엮는(wiring) 작업의 형태로 개발한다.
				ApplicationContext가 관리하는 객체들을 Bean이라 부르고,
				Bean과 Bean 사이의 의존 관계를 처리하는 방식으로
				XML설정(필수), {@ 설정, Java설정}(택1) 방식을 이용할 수 있다.
			
		- AOP 지원
			Aspect-Oriented-Programming
			【관점 지향 프로그래밍】
			횡단 관심사를 모듈(메소드)로 분리하는 프로그래밍
			비지니스 로직은 아니지만 【보안이나 로그(출력), 트랜잭션, 예외 등과 같이
			반드시 처리가 필요한 부분을 횡단 관심사(cross-concern)】이라고 한다.
			스프링 프레임워크는 횡단 관심사를 분리해서 제작하는 것이 가능하다.
				※ 종단 관삼사 : 비지니스 로직

			장점
				- 핵심 비지니스 로직에만 집중하여 코드 개발
				- 각 프로젝트마다 다른 관심사 적용 시 코드 수정 최소화
				- 원하는 관심사의 유지보수가 수월한 코드 구성 가능

		- 편리한 MVC 구조
		- WAS에 종속적이지 않은 개발 환경
		- 트랜잭션 관리 용이
			DB 작업 시 트랜잭션 관리를 매번 상황에 맞게 코드로 작성하지 않고,
			@이나 XML로 트랜잭션 관리를 설정할 수 있다.
----------------------------------------------------------------------------------------------------------
프로젝트 기본 구성 요소
	- src/main/java : 작성되는 코드의 경로(비지니스 로직 작성)
	- src/main/resources : 실행할 때 참고하는 기본 경로
	- src/test/java : 테스트 코드를 넣는 경로(테스트 하는 곳)
	- src/text/resources : 테스트 관련 설정 파일 보관 경로

웹과 관련된 스프링 설정 파일(Resources, ViewResolver)
	src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml

스프링 설정 파일(Bean, IoC 컨테이너)
	src/main/webapp/WEB-INF/spring/root-context.xml

	※ IoC : 제어권의 역전
		객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것

	※ IoC 컨테이너 : 객체에 대한 생성 및 생명주기를 관리할 수 있는 기능을 제공
			컨테이너가 흐름의 주체가 된다.

Tomcat의 web.xml 파일(Front-Controller, DispatcherServlet)
	src/main/webapp/WEB-INF/web.xml

템플릿 프로젝트의 jsp 파일
	src/main/webapp/WEB-INF/views

Maven이 사용하는 pom.xml
	project/pom.xml
	
	※ Maven : 자바용 프로젝트 관리도구로,
			필요한 라이브러리를 pom.xml에 정의해 놓으면
			내가 사용할 라이브러리 뿐만 아니라 해당 라이브러리가 작동하는데에
			필요한 다른 라이브러리들까지 관리하여 네트워크를 통해
			자동으로 다운받아 준다.
	※ pom : Project Object Model
----------------------------------------------------------------------------------------------------------
@Component
	스프링에게 해당 클래스가 스프링에서 관리해야 하는 대상임을 표시
	보통 Model 객체에 다 붙여준다.

	@Component가 있는 패키지 등록
		root-context.xml > 하단의 Namespace > context 체크
		> Source에 <context:component-scan base-package="@Component가 있는 패키지명"/>
		
@Data
	Lombok이 setter, getter, 생성자, toString() 등을 자동으로 생성
	만약 getter만 필요하면 @Getter로 별도 생성도 가능하다.

@Setter(onMethod_ = @Autowired)
private 클래스명 객체명;
	해당 클래스의 생성자를 가져와서 할당한다.
	※ onMethod : 생성되는 setter에 @Autowired를 추가하도록 할 때 사용
			버전에 따라 다르기 때문에 오류나면 _를 추가한다.

※ S가 아이콘에 없으면 @Component를 안했거나, root-context.xml에 패키지 등록을 안한 것
※ root-context.xml에서 코드색이 변하지 않는 경우
	root-context.xml 우클릭 > Open with > Spring Config Editor
----------------------------------------------------------------------------------------------------------
스프링 프레임워크 동작 시 생기는 일
	1. 스프링이 사용하는 메모리 영역을 만든다(Context).
	2. 스프링은 자신이 객체를 생성하고 관리해야 하는 객체들에 대한 설정이 필요하고,
		이 설정 파일이 root-context.xml이다.
	3. root-context.xml에 작성한 <context:component-scan>의 내용을 통해서
		패키지를 스캔하기 시작한다.
	4. 해당 패키지에 있는 클래스들 중에서 @Component가 존재하는 클래스의 인스턴스를 생성한다.
	5. @Setter(onMethod_ = @Autowired) 처리
----------------------------------------------------------------------------------------------------------
테스트 서버
	src/test/java에 생성
	
	@RunWith(SpringJUnit4ClassRunner.class)
		테스트 코드가 스프링을 실행

	@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
		지정된 클래스나 문자열을 이용해서 필요한 객체들을 스프링 내에 객체로 등록

	@Log4j
		private static final Logger logger = LoggerFactory.getLogger(HomeController.class)와 동일
		Log.info() == System.out.println()

	assertNotNull(객체명);
		객체명이 Null이 아니어야만 테스트 성공
		만약 Null이라면 밑에 코드들은 실행되지 않음

	@AllArgsConstructor
		인스턴스 변수로 선언된 모든 것을 파라미터로 받는 생성자를 생성
		만약 @NonNull이 있다면 예외처리도 자동 생성
		ex)
			private String s1;
			private String s2;
			@NonNull
			private String s3;

			public 클래스명(String s1, String s2, String s3){
				if(t3 == null){
					throw new NullPointException();
				} else {
					this.t1 = t1;
					this.t2 = t2;
					this.t3 = t3;		
				}
			}

	@RequiredArgsConstructor
		@NonNull이나 final이 붙은 변수에 대한 생성자를 생성
		ex)
			private String s1;
			private final String s2;
			@NonNull
			private String s3;

			public 클래스명(String s2, @NonNull String s3){
				if(t3 == null){
					throw new NullPointException();
				} else {
					this.t2 = t2;
					this.t3 = t3;		
				}
			}
----------------------------------------------------------------------------------------------------------
try(Statement)
	Statement 자리에 close를 필요로 하는 인스턴스를 작성하면 자동으로 close() 한다.
	ex)
		try(Connection conn = 
			DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE",	
			"hr",
			"hr")){
			Log.info(conn);
		}catch(Exception e){
			fail(e.getMessage());
		}

		※ fail() : 테스트를 종료

<bean id="" class="" destroy-method="">
	객체를 생성하는 태그
	id에는 객체명,
	class에는 패키지명.클래스명,
	destory-method에는 종료 시 사용할 메소드

<constructor-arg ref="참조할 객체명"/>
----------------------------------------------------------------------------------------------------------
SQL문을 항상 인터페이스에 매핑
	SQL이 복잡하거나 길어지는 경우에는 @보다는 XML을 이용하는 방식을 더 선호하게 된다.
	MyBatis-Spring의 경우 Mapper 인터페이스와 XML을 동시에 이용할 수 있다.

	root-context.xml
		<mybatis-spring:scan base-package="패키지명"/> 추가

	1. XML을 이용할 경우
		src/main/resources/META-INF안에 폴더를 생성하고 xml 파일 생성
			여기서 폴더는 오류가 날 수 있으므로 하나씩 개별 생성
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 추가
		
		<mapper namespace="인터페이스가 있는 패키지와 인터페이스 이름">
		id에는 인터페이스에 있는 추상메소드의 이름을 쓴다.
		나머지는 model2 방식과 동일
		
	2. 인터페이스
		@Select("쿼리문")
			이 부분에 쿼리문을 작성한다.
			SELECT면 @Select, DELETE면 @Delete
		public String 추상메소드명();
			【추상메소드가 실행되면 쿼리문이 실행되는 것】

		※ 사용은 컨트롤러에서 인터페이스만 객체화해서 사용
----------------------------------------------------------------------------------------------------------
MVC model2를 사용하는 이유
	- 분업★★★
	- 유지보수
	- 페이지가 많기 때문에

(Spring MVC)Front-Controller 패턴
	            HandlerMapping
	        ①          ↕②        ③                      ④
	Client ↔ DispatcherServlet ↔ HandlerAdapter ↔ Controller
	        ⑥          ↕⑤
	              ViewResolver
	
	진행 순서(↑와 다름)
		1) 사용자의 모든 Request(URL)는 Front-Controller인 DispatcherServlet을 통해 처리한다(web.xml).
		2) HandlerMapping은 Request의 처리를 담당하는 컨트롤러를 찾기 위해 존재한다.
			@RequestMapping, @Controller가 적용된 것을 기준으로 판단하며,
			적절한 컨트롤러가 찾아졌다면 HandlerAdapter를 이용해서
			해당 컨트롤러를 동작시킨다.
			※ @XXXXMapping() : 요청이 매개변수에 있는 값이면 들어와라
			※ @Controller : 자동으로 스프링의 객체(Bean)로 등록된다.
			
			ex)
			- RequestMapping("/sample/*")
				sample로 시작하는 모든 애들은 이쪽으로 들어온다.

			- RequestMapping("")
				들어온 것 중에 sample뒤에 아무것도 없는 경우 들어온다.

			- RequestMapping(value="/basic", method={RequestMethod.GET, RequestMethod.POST})
				여러 개의 응답 방식을 사용할 경우 url은 value에 담아준다.

			※ RequestMapping은 GET과 POST 둘 다 사용할 경우만 쓴다.
				
			@GetMapping("/basicOnlyGet")
				GET방식으로 요청한 것만 들어온다.

			@PostMapping("/basicOnlyPost")
				POST방식으로 요청한 것만 들어온다.

		3) Controller는 Request를 처리하는 비지니스 로직을 작성하며,
			View에 전달해야 하는 데이터는 주로 Model 객체에 담아서 전달한다.
		4) ViewResolver는 Controller가 리턴한 결과를 
			어떤 View에서 처리하는 것이 좋을 지 해석하는 역할(servlet-context.xml)
		5) 만들어진 응답은 DispatcherServlet을 통해서 전송된다.

	※ 내가 생각한 순서
		사용자에게 요청(URL)이 들어오면 web.xml은 모든 URL을 DispatcherServlet으로 보내는데
		그 과정에서 servlet-context.xml에 가서 <context:component-scan>에 들어있는 패키지로 가서
		@Controller가 붙어있는 컨트롤러들을 객체화하고 @OOOMapping 중 어떤걸 실행할지 찾아서
			이 부분이 HandlerMapping
		실행 후 view와 model을 응답함
		그럼 다시 DispatcherServlet으로 돌아와서 컨트롤러에서 받은 view에 servlet-context.xml을 참고하여
		리턴값 앞에는 prefix, 뒤에는 suffix를 붙여서 어떤 jsp에 응답할지 알아낸 후 model을 넘겨준다.
			이 부분이 ViewResolver

		servlet-context.xml은 HandlerMapping과 ViewResolver 둘 다 사용하는 것

	
Spring MVC Controller 특징
	- HttpServletRequest, HttpServletResponse를 거의 사용할 필요가 없다.
	- 다양한 타입의 파라미터 처리, 다양한 타입의 리턴 타입 사용 가능
	- GET, POST 등 전송 방식에 대한 처리를 @으로 가능
	- 상속/인터페이스 방식 대신 @만으로도 설정 가능

Model(데이터 전달자)
	Model 객체는 컨트롤러에서 생성된 데이터를 담아서 JSP에 전달하는 역할
	반면 기본 자료형의 경우 파라미터로 선언하더라도 화면까지 전달되지 않는다.
		내가 만든 클래스 객체는 Model을 안붙여도 된다.
		자바에서 제공하는건 Model을 붙여야 한다.
			ex) String, int, ArrayList, [] 등

	@GetMapping("/ex01")
	public String ex01(SampleDTO dto){ }
		파라미터 타입에 따라 자동으로 매핑된다.

	@GetMapping("/ex02")
	public String ex02(@RequestParam("data1") String name, @RequestParam("data2") ing age, Model model){ }
		파라미터와 매개변수의 이름이 다를 경우 사용
		쿼리스트링에 key가 data1이면 name에, data2면 age에 담는다.
		그냥 name과 age를 사용할꺼면 @RequestParam()을 지운다.

	@GetMapping("/ex03")
	public String ex03(@RequestParam("data") ArrayList<String> datas, Model model){ }
		쿼리스트링에 key가 data면 datas라는 ArrayList에 담는다.

	@GetMapping("/ex04")
	public String ex04(@RequestParam("data") String[] datas, Model model){ }
		쿼리스트링에 key가 data면 datas라는 String[]에 담는다.

	@GetMapping("/ex05")
	public void ex05(SampleDTO dto, @ModelAttribute("gender") String gender){ }
		참조형과 기본형을 같이 사용할 수 있다.
		※ 요청한 경로와 같은 경로로 리턴하는 경우 void를 사용해도 된다.
			다른 경로로 리턴하는 경우 리턴을 써준다.