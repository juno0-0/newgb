DBeaver
	build path에 ojdbc6.jar 넣기

try(Statement) : Statement 자리에 close를 필요로 하는 인스턴스를 작성하면 자동으로 close()를 실행해준다.

		try(Connection conn = 
				DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE",
				"hr",
				"hr")){
			log.info(conn);
		}catch(Exception e) {
			fail(e.getMessage());
			// fail() : 테스트를 종료
		}

DBCP 추가하기
	pom.xml에 109줄에 
	</dependencies>
	</dependencies> 사이에
	<!-- https://mvnrepository.com.artifact/com.zaxxer/HikariCP -->
	<dependency>
		<groupId>com.zaxxer</groupId>
		<artifactId>HikariCP</artifactId>
		<version>2.7.4</version>
	</dependency> 추가하기

root-context.xml에 객체를 생성(추가)하기	
	// DataSource객체가 참고하기 위한 객체 생성하는 것
	// hikari는 dbcp의 종류, Spring에서 쓰면서 효율이 좋은 애
	// config로 기본 설정하는 것
	<bean id="hikariConfig" class="om.zaxxer.hikari.HikariConfig">
		// 필드 생성
		<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
		<property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:XE"/>
		<property name="username" value="hr"/>
		<property name="password" value="hr"/>
	</bean>
	// DataSource 객체 생성
	// hikari를 참고해서 connection 객체를 받아오는 것
	<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
		※ destroy-method : 종료할 때 무슨 메소드 쓸래?
		// hikariConfig를 참조할껍니다.
		<constructor-arg ref="hikariConfig"/>	
	</bean>

	※ 【값을 직접 가져올 때는 value, 참조할 때는 ref】

	※ Mybatis가 dataSource를 참조해서 가져오는 것

	※ pom = project object model

	※ 【객체화를 해야할 때는 root-context.xml로 간다.】

Mybatis 추가하기
	Hikari 추가한 곳 밑에
	<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis</artifactId>
		<version>3.4.6</version>
	</dependency>
      
	<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis-spring</artifactId>
		<version>1.3.2</version>
	</dependency>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-tx</artifactId>
		<version>${org.springframework-version}</version>
	</dependency>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-jdbc</artifactId>
		<version>${org.springframework-version}</version>
	</dependency> 추가하고 저장 후 프로젝트 업데이트

	root-context.xml에
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 값을 직접 가져올 때는 value, 참조할 때는 ref -->
		<property name="dataSource" ref="dataSource"/>
	</bean> 추가하기

	※ 결론적으로 dataSource가 참조하기 위해 hikariConfig를 만든 것이고,
		mybatis가 참조하기 위해 dataSource를 만든 것

※ hikari : DBCP의 한 종류
※ dataSource : JNDI의 핵심 객체
		DB와 통신을 하는 역할
		DBCP와 한 묶음으로 봐야 함
※ JDBC를 조금 더 편하게 쓰기 위해서 사용하는게 DBCP와 JNDI이고,
	DBCP와 JNDI를 조금 더 편하게 쓰기 위해 사용하는게 MyBatis이다.
	MyBatis는 hikari를 참조하여 사용하는 것
		jsp에서는 hikari와 dataSource의 설정을 Servers의 context.xml에서 한다.

SQL문을 항상 인터페이스에 매핑
	SQL이 복잡하거나 길어지는 경우에는 어노테이션보다는 XML을 이용하는 방식을 더 선호하게 된다.
	【MyBatis-Spring의 경우 Mapper 인터페이스와 XML을 동시에 이용할 수 있다.】

	root-context.xml
		<mybatis-spring:scan base-package="com.koreait.mapper"/> 추가

	1. XML파일 
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd">를 추가한다.
	
		【namespace에는 인터페이스가 있는 패키지와 인터페이스 이름】을 쓴다.
		【id에는 인터페이스에 있는 추상메소드의 이름】을 쓴다.
	
		XML파일을 만드는 경로
			src/main/resources > META-INF > 경로들
				여기서 폴더는 오류가 날 수 있으므로 하나하나 직접 만들어준다.

	2. 인터페이스
		@Select("쿼리문")
			// 여기에 쿼리문을 작성하는 것, 
			// SELECT면 @Select,
			// UPDATE면 @Update를 쓰는 것
		public String getTime(); 
			// 이 【메소드가 실행되면 위에 쿼리문이 실행】되는 것★★

	※ 사용은 인터페이스만 컨트롤러에서 객체화해서 사용하면 된다.


MyBatis는 내부적으로 JDBC의 PreparedStatement를 이용해서 SQL을 처리한다.
따라서 SQL에 전달되는 파라미터는 JDBC에서와 같이 '?'로 치환되어 처리된다.
복잡한 SQL의 경우 '?'로 나오는 값이 제대로 되었는 지 확인하기 쉽지 않고 실행된 SQL의
내용을 정확히 확인하기 어렵기 때문에 log4jdbc-log4j2라이브러리를 사용하여 어떤 값인지를
정확히 확인한다.
	pom.xml 140줄에
	</dependency>
	</dependency> 사이에
	<!-- https://mvnrepository.com/artifact/org.bgee.log4jdbc-log4j2 -->
		<dependency>
		<groupId>org.bgee.log4jdbc-log4j2</groupId>
		<artifactId>log4jdbc-log4j2-jdbc4</artifactId>
		<version>1.16</version>
	</dependency> 추가하기

	src/main/resources에 Untitled 파일 만들고
		log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator 추가 후 저장
		이름을 log4jdbc.log4j2.properties로 하고 ex00/src/main/resources에 저장

	root-context.xml에서 hikariConfig의 property에
		driverClass와 jdbcUrl 기존꺼 주석하고
		<property name="driverClassName" value="net.sf.log4jdbc.sql.jdbcapi.driverSpy"/>
		<property name="jdbcUrl" value="jdbc:log4jdbc:oracle:thin:@localhost:1521:XE"/> 추가

	log4j.xml에 log 파일 설정을 하는 것
		<logger name="jdbc.audit">
			<level value="warn"/>
		</logger>
	
		<logger name="jdbc.resultset">
			<level value="warn"/>
		</logger>
	
		<logger name="jdbc.connection">
			<level value="warn"/>
		</logger> 추가
		info는 설명, warn은 경고단계

※ 스프링은 new를 직접하지 않는다.
---------------------------------------------------------------------------------------------------------------
MVC model2를 사용하는 이유
	- 분업★
	- 유지보수
	- 페이지가 많아서

(Spring MVC)Front-Controller 패턴
	
	HandlerMapping
        ①         ↕②	          ③	         ④
Client ↔ DispatcherServlet  ↔  HandlerAdapter ↔  Controller
        ⑥         ↕⑤
	ViewResolver

	위 순서와 다름
	1. 사용자의 모든 Request(URL)는 Front-Controller인 DispatcherServlet를 통해 처리한다(web.xml 참고)
	2. HandlerMapping은 Request의 처리를 담당하는 컨트롤러를 찾기 위해 존재한다.
		HandlerMapping 인터페이스를 구현한 여러 객체 중 @RequestMapping, @Controller 어노테이션이 
			※ @Controller : 자동으로 스프링의 객체(Bean)로 등록된다.
			※ @XXXXMapping() : 만약 매개변수에 있는 값이 요청으로 들어오면 들어와라
		적용된 것을 기준으로 판단하며, 적절한 컨트롤러가 찾아졌다면 HandlerAdapter를 이용해서 
		해당 컨트롤러를 동작시킨다.
	3. Controller는 Request를 처리하는 비지니스 로직을 작성하며, 
		View에 전달해야 하는 데이터는 주로 Model객체에 담아서 전달한다. 
		이에 대한 처리는 ViewResolver를 이용하게 된다.
	4. ViewResolver는 Controller가 리턴한 결과를 어떤 View에서 처리하는 것이 좋을 지 해석하는 역할이다.
		(servlet-context.xml 참고)
	5. 만들어진 응답은 DispatcherServlet을 통해서 전송된다.

	Client가 URL로 요청하면 web.xml을 들렀다가 DispatcherServlet로 이동
	DispatcherServlet가 HandlerMapping으로 컨트롤러 찾음
	DispatcherServlet에서 HandlerAdapter로 갔다가 Controller로 이동했다가
	다시 HandlerAdapter로 와서 DispatcherServlet로 돌아옴
	그럼 마지막으로 ViewResolver로 갔다가 DispatcherServlet으로 와서 Client에게 응답한다.

	Client > DispatcherServlet > HandlerMapping(컨트롤러 찾음) > DispatcherServlet >
	> HandlerAdapter > Controller > HandlerAdapter > DispatcherServlet 
	> HandlerResolver > DispatcherServlet > Client

Spring MVC Controller 특징
	- HttpServletRequest, HttpServletResponse를 거의 사용할 필요 없이 기능 구현
	- 다양한 타입의 파라미터 처리, 다양한 타입의 리턴 타입 사용 가능
	- GET방식, POST방식 등 전송 방식에 대한 처리를 어노테이션으로 처리 가능
	- 상속/인터페이스 방식 대신 어노테이션만으로도 설정 가능

Model(데이터 전달자)
	Model객체는 【컨트롤러에서 생성된 데이터를 담아서 JSP에 전달하는 역할】을 한다.
	반면 기본 자료형의 경우에는 파라미터로 선언하더라도 화면까지는 전달되지 않는다.
		【참조형】은 Model을 쓰지 않아도 【바로 전달】된다.
		【기본형】은 【Model을 써야만 전달】된다.
			사용자가 직접 만든 클래스 객체는 바로 전달
			자바에서 만들어둔 것을 쓰면 Model로 전달

	@RequestMapping("/sample/*")
		sample로 시작하는 모든 애들은 이쪽으로 들어와라

	1) @RequestMapping("")
		sample/ 뒤에 아무것도 없는 경우 들어온다.

	2) @RequestMapping(value="/basic", method= {RequestMethod.GET, RequestMethod.POST})
		여러 개의 RequestMethod를 사용할 경우만 사용
		method를 사용할 경우 value에 sample/의 나머지 경로를 담아준다.

	3) @GetMapping("/basicOnlyGet")
		GET방식으로 요청한 것만 들어온다.

	4) @PostMapping("/basicOnlyPost")
		POST방식으로 요청한 것만 들어온다.
	
	5) @GetMapping("/ex01")
		public String ex01(SampleDTO dto){ }
		파라미터 타입에 따라 자동으로 매핑된다.

	6) public STring ex02(@RequestParam("data1") String name, @RequestParam("data2") int age, Model model){ }
		파라미터와 매개변수의 이름이 다를 경우
		쿼리스트링에 key가 data1이면 name에, data2면 age에 담는다.
		key를 name과 age로 쓸꺼면 @RequestParam()을 지운다.

	7) public String ex03(@RequestParam("data") ArrayList<String> datas, Model model){}
		쿼리스트링에 key가 data면 전부 ArrayList에 담는다.

	8) public String ex04(@RequestParam("data") String[] datas, Model model){}
		쿼리스트링에 key가 data면 전부 배열에 담는다.

	9) public void ex05(SampleDTO dto, @ModelAttribute("gender") String gender){}
		참조형과 기본형을 같이 쓸 수 있다.
		※ 요청한 경로랑 같은 경로로 리턴하는 경우 void를 써도 되고,
			다른 경로로 리턴하는 경우 리턴을 써준다.

	예시)
		// 파라미터와 매개변수의 이름이 다를 경우
		@GetMapping("/ex02")
		public String ex02(@RequestParam("data1") String name, @RequestParam("data2") int age, Model model) {
			//RequestParam()의 매개변수가 data1이면 뒤에 있는 name에 넣어라
			//RequestParam()의 매개변수가 data2이면 뒤에 있는 age를 넣어라
		
			log.info("name : "+name);
			log.info("age : "+age);
			model.addAttribute("name", name);
			model.addAttribute("age", age);
			return "ex02";
		}


※ 프로젝트를 새로 만들면 
	log4jdbc.log4j2.properties
	log4j.xml
	pom.xml만 복붙


