파일 업로드 방식
	- <form>태그를 이용하는 방식
	- Ajax를 이용하는 방식
	- <iframe>을 이용하여 화면의 이동 없이 첨부파일을 처리하는 방식
		※ <iframe> : 브라우저 안에 또 다른 브라우저를 띄울 수 있는 것
				너무 많은 렌더링을 필요로 하고, 보안이 나쁘다.

파일 업로드 API
	- cos.jar : 2002년 이후로 개발 종료, 더 이상 사용하지 않는 것을 권장
	- commons-fileupload : 일반적으로 많이 활용되며, 서블릿 3.0 이전에도 사용 가능
	- 서블릿 3.0 이상부터는 API상에서 지원
	
	pom.xml에서 
		<!-- Servlet --> 안에
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version> // 버전 확인하기
			<scope>provided</scope>
		</dependency>

		<!-- AsepectJ --> 바로 아래에
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjweaver</artifactId>
			<version>${org.aspectj-version}</version>
		</dependency>

		맨 위쪽에 properties에서
		<org.aspectj-version>1.9.0</org.aspectj-version>
		<org.slf4j-version>1.7.25</org.slf4j-version>로 수정

	web.xml
		맨 위쪽에
		<web-app version="3.1" xmlns="http://java.sun.com/xml/ns/javaee"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
			https://java.sun.com/xml/ns/javaee/web-app_3_1.xsd"
		id="WebApp_ID">
		이걸로 수정하기

		<servlet> 안에
		<multipart-config>
			<!-- 업로드 경로 -->
			<!-- <location>을 사용하는 이유 -->
			<!-- ① temp 안에 임시 저장이 되었다가 성공 시 temp에서 사라지고 upload로 들어가는 것 -->
			<!-- ② 업로드 되는 최대 크기를 넘었을 때 오류가 나면서 사라지는게 아니라 temp에 저장이 된다. -->
			<!-- 단, 첨부파일을 보내지 않으면(null) 이 경로로 아예 오지 않는다. -->
			<!-- 되도록 location의 경로는 파일 업로드 처리가 완료될 디렉토리 안으로 설정해주는 것이 좋다. -->
			<location>C:\\upload\\temp</location>
			<!-- 업로드 되는 파일의 최대 크기(20MB) -->
			<!-- 1024 * 1024 * 20 -->			
			<max-file-size>20971520</max-file-size>
			<!-- 한 번에 올릴 수 있는 최대 크기(40MB) -->
			<max-request-size>41943040</max-request-size>
			<!-- 20MB 메모리 사용 -->
			<!-- 스레드 하나 당 메모리 -->			
			<file-size-threshold>20971520</file-size-threshold>
		</multipart-config>

	servlet-context.xml
		<beans:bean id="multipartResolver" class="org.springframework.web.multipart
		.support.StandardServletMultipartResolver"></beans:bean> 추가

	※ enctype="application/x-www-form-urlencoded"는 contentType의 Default값과 같다.

<input type="file" name="uploadFile" 【multiple】>
	multiple 속성을 작성하면, 여러 개의 파일을 업로드 할 수 있다.
	여기서 입력받은 【첨부파일이 uploadFile이라는 배열의 형태로 Controller로 전송된다.】

public void uploadFormPost(【MultipartFile[]】 uploadFile){ }
	jsp에서 multiple 속성으로 보낸 첨부파일 배열을 받는 것

String uploadFolder = "C:\\upload";
	첨부파일을 업로드 할 경로

for(MultipartFile multipartFile : uploadFile){ }
	각 multipart 객체를 빠른 for문을 사용해서 순서대로 가져온다.

File saveFile = new File(uploadFolder, multipartFile.getOriginalFilename());
	전체 경로를 File 객체에 담아준다.
	【File 타입으로 해놔야 byte전송이 된다.】

transferTo(File file);
	【해당 경로에 해당 파일를 바이트로 입력되게 하는 역할】

File uploadPath = new File(uploadFolder, getFolder());
	사용자가 업로드를 한 시간인 년, 월, 일을 디렉토리로 만드는 getFolder()를 사용한다.

getFolder(){
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
	//현재 날짜
	Date date = new Date();
	String str = sdf.format(date);
	return str.replace("-", File.separator);

	※ File.separator
		상위 디렉토리에서 하위로 갈 때의 문자열 형식
		\\ 혹은 /를 의미한다.
}

if(!uploadPath.exists)){
	uploadPath.mkdirs();
}
	만약 해당 디렉토리가 존재하지 않으면 만들어준다.
	mkdir()은 해당 디렉토리가 없으면 오류가 난다.

uploadFileName = uploadFileName.substring(uploadFileName.lastIndexOf("\\") + 1);
	IE에서는 파일 이름만 가져오지 않고 전체 경로를 가져오기 때문에
	마지막에 위치한 파일 이름만 가져오도록 한다.
	IE 이외의 브라우저에서는 \\가 없기 때문에 -1 + 1로 연산되어 0번째 즉, 파일 이름을 의미한다.
		substring은 결과가 없으면 -1을 리턴하기 때문이다.

Controller에서 @RequestMapping를 쓰지 않은 이유
	해당 메소드에서 알려주기 때문이다.
	jsp에서 보낼 때는 localhost:8085/upload/ 인 상태에 action을 붙이는 거라서
	/를 생략하는 것이다.

*문제점 및 해결방안
1. 동일한 이름으로 파일이 업로드 되었을 때 기존 파일이 사라지는 문제(덮어 씌워진다)
	밑에 나오는 UUID를 사용

2. 첨부파일 공격에 대비하기 위한 업로드 파일의 확장자 제한
	function check(fileName, fileSize){
		//정규식을 쓰면 속도가 반복문보다 빠르다.
		//비교하는 대상이 마침표 뒤에 있는것
		//\를 기준으로 앞의 (.*?)와 (exe|sh|zip|alz)를 비교하는 것
		var regex = new RegExp("(.*?)\.(exe|sh|zip|alz)$");
		//maxSize를 5MB로 설정
		var maxSize = 5242880;
		if(regex.test(fileName)){
			alert("업로드 할 수 없는 파일의 형식입니다.");
			return false;
		}
		
		if(fileSize > maxSize){
			alert("파일 사이즈 초과");
			return false;
		}
		return true;
	}
3. 이미지 원본 파일 용량이 큰 경우 썸네일 이미지를 생성해야 한다.
4. 이미지 파일과 일반 파일을 구분해서 다운로드를 처리해야하는 문제
	Files.probeContentType(file.toPath()).startsWith("image");
		사용자가 업로드한 파일의 타입이 image 타입인지 확인하는 것


*중복 방지를 위한 UUID(Universally Unique IDentifier) 범용 고유 식별자 적용
	중복이 될 경우 덮어씌워지는 것을 방지하고자 하는 것	

	UUID
		네트워크 상에서 각각의 객체들을 식별하기 위하여 사용되었다.
		중복될 가능성이 거의 없다고 인정되기 때문에 많이 사용된다.

	UUID 개수
		340,282,366,920,938,463,463,374,607,431,768,211,456개
		10의 38승 : 만4, 억8, 조12, 경16, 해20, 자24, 양28, 구32, 간36
		340간개

	UUID uuid = UUID.randomUUID();
	uploadFileName = uuid.toString() + "_" + uploadFileName;
		거의 모든 중복을 막는 코드로, 랜덤한 UUID를 담아놓는다.
		파일 이름이 중복되더라도 이름 앞에 UUID를 붙여주기 때문에
		중복될 가능성이 희박하다.

var contextPath = "${pageContext.request.contextPath}";
	이건 모듈에 입력한 경로를 리턴한다.
	/upload
	
Ajax
	데이터에 파일이 있을 경우 반드시 설정해야 한다.

	processData: false
		http://example.com/over/there?【title=Main_page&action=raw】
		data 파라미터로 전달된 데이터를 jQuery 내부적으로 쿼리스트링으로 만드는데, 
		파일 전송의 경우 이를 하지 않아야 하고 그 설정이 processData: false이다.

	contentType: false
		contentType의 Default는 "application/x-www-form-urlencoded; charset=UTF-8"인데
		multipart/form-data로 전송이 되게 false로 넣어준다.
		multipart/form-data가 아니고 false를 넣는 이유는
			"multipart/form-data"를 직접 넣게 되면
			boundary string이 안들어가게 되어 전송된 파일 정보와 매칭되지 않아 오류 발생
			※ boundary string : 전송되는 데이터의 영역을 구분해주는 구분자
				multipart/form-data; boundary=----WebKitFormBoundarybuOGBs9coioS5Kb9

	※ false로 주면 Default도 사용하지 않겠다는 의미
----------------------------------------------------------------------------------------
썸네일 이미지 생성
	용량이 큰 파일을 모바일과 같은 환경에서 처리한다면
	많은 데이터를 소비해야 한다.
	따라서 특별한 경우가 아니라면 썸네일을 제작해야 한다.
	하나의 이미지파일을 업로드하면 Application에서 사용되는 다양한 해상도 썸네일로
	만들어 낼 수 있으며, 다운로드하지 않고도 미리보기가 가능해진다.

NCS
	직무를 수행하기 위해 요구되는 내용을 국가가 체계화 한 것


※ JDK 11인가 13부터는 var 타입을 사용할 수 있다.