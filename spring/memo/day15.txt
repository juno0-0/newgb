contentType: false
	여기에 만약 "multipart/form-data"를 직접 넣게 되면
	boundary key라는게 자동으로 생성되지 않아서 오류가 발생한다.
-----------------------------------------------------------------------------------------------------------
//모든 첨부파일을 가지고 있는 DTO
AllFileDTO allFile = new AllFileDTO();
	
//첨부파일 업로드 성공 시 들어갈 객체
List<AttachFileDTO> succeedList = new ArrayList<>();
		
//첨부파일 업로드 실패 시 들어갈 객체
List<AttachFileDTO> failureList = new ArrayList<>();

//첨부파일 정보를 가지고 있는 객체
//받아올 때마다 초기화
AttachFileDTO attachDTO = new AttachFileDTO();

//UUID가 붙지 않은 실제 파일명을 저장
attachDTO.setFileName(uploadFileName);

InputStream in = new FileInputStream(saveFile);
				
attachDTO.setUuid(uuid.toString());
attachDTO.setUploadPath(uploadFolderPath);

//save할 경로에서 파일을 가져오는 객체
InputStream in = new FileInputStream(saveFile);

//이미지인지 아닌지
attachDTO.setImage(boolean);

//Stream : 파일을 통신할 때 byte가 이동할 경로이다.
//그냥 saveFile을 쓰게 되면 이름 구분을 할 수 없기 때문에 new File()
//첨부파일이 이미지일 시 썸네일을 내보내 줄 역할
FileOutputStream thumbnail = new FileOutputStream(new File(uploadPath, "s_"+uploadFileName));

//Thumbnailator.createThumbnail(multipartFile.getInputStream(), thumbnail, 100, 100);
//Thumbnailator.createThumbnail(InputStream, OutputStream,  width, height);
//파일을 가져와서 100 x 100으로 만들어서 다시 내보낸다
Thumbnailator.createThumbnail(in, thumbnail, 100, 100);

//첨부파일 등록 성공 시 
succeedList.add(attachDTO);

//첨부파일 등록에 실패해서 catch에 들어갔을 시
failureList.add(attachDTO);

//성공, 실패 리스트를 AllFileDTO에 담는다.
allFile.setSucceedList(succeedList);
allFile.setFailureList(failureList);
return new ResponseEntity<AllFileDTO>(allFile, HttpStatus.OK);

//fileName을 통해 썸네일 뿌려주기
@GetMapping("/display")
@ResponseBody
public ResponseEntity<byte[]> getFile(String fileName){
	log.info("fileName : "+fileName);
	File file = new File("C:\\upload\\"+fileName);
	log.info("file : "+file);
	
	ResponseEntity<byte[]> result = null;
	HttpHeaders header = new HttpHeaders();
	
	try {
		//헤더에 적절한 파일의 타입을 probeContentType을 통하여 포함시킨다.
		header.add("Content-Type", Files.probeContentType(file.toPath()));
		//이미지 파일이 날아가는 것(이름이나 이런거 X)
		//new ResponseEntity<byte[]>(byte[], MultiValueMap<> header, status);
		//copyToByteArray : 지정한 InputStream의 내용을 새로운 byte[]에 copy한다 완료되면 Stream을 닫는다.
		//리턴값은 copy된 새로운 byte[]을 리턴한다(빈값이 들어올 수 있다).
		result = new ResponseEntity<byte[]>(FileCopyUtils.copyToByteArray(file), header, HttpStatus.OK);
	} catch (IOException e) {
		e.printStackTrace();
	}
	return result;
}

$("#uploadBtn").on("click", function(){
		var formData = new FormData();
		var inputFile = $("input[name='uploadFile']");
		var files = inputFile[0].files;
			
		console.log(files);
		
		//문제점 및 해결방언 3번
		for(let i=0; i<files.length; i++){
			//여기서 name은 property
			if(!check(files[i].name, files[i].size)){
				return false;
			}
			formData.append("uploadFile", files[i]);
		}
			
		$.ajax({
			url: contextPath + "/uploadAjaxAction",
			//이 두개를 false로 주는건 default 조차 쓰지 않겠다는 의미
			processData: false,
			contentType: false,
			data: formData,
			/* 파일은 get이 불가능 */
			type: "post",
			dataType: "json",
			success: function(result){
			console.log(result);
			showUploadFile(result.succeedList, uploadResult);
			if(result.failureList.length != 0){
				showUploadFile(result.failureList, uploadFail);
				$(".uploadFail").show();
			}else{
				$(".uploadFail").hide();
			}
			//input이 있는 Div 비우는 것
			//html() : 가져온걸 html로 변경해주는 것
			$(".uploadDiv").html(cloneObj.html());
		}
	});	
});


encodeURIComponent("문자열값")
	GET방식으로 전송 시 파라미터로 전달할 때, 값에 인식할 수 없는 문자가 있을 경우 쿼리 스트링 문법에 맞게 변경해야 한다.
	이 때 사용하는 메소드이다.

SPA
	Single Page Application
	하나의 페이지로 다 하는 것