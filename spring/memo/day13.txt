AOP(Aspect-Oriented-Programming)
	관점 지향 프로그래밍
	관점이란 개발에 있어서, 관심사(concern)를 의미한다.
	관심사는 개발 시 필요한 것들을 생각하는 일이며,
	아래와 같다.

	- 파라미터가 잘 전달 되었는가?
	- 이 로직에서 발생할 수 있는 모든 예외를 처리하자!
	- 적절한 권한을 가진 사용자가 작업하고 있는가?

	핵심 로직은 아니지만 반복적으로 개발에 필요한 관심사들이다.
	따라서 AOP는 이러한 것들을 【모듈로 분리】하여 작성하고
	핵심 비지니스 로직만을 작성하도록 한다.

	예시)
	나눗셈 프로그램 개발 시 두 개의 숫자를 나누는 것은 핵심로직(종단관심사),
	0으로 나누는 지 체크하는 것을 주변로직(횡단관심사)이라고 한다.

	즉, 【반복적으로 나타나는 횡단관심사를 
	모듈로 분리한 후 적절한 곳에 로직을 주입하는 것이 AOP이다.】
	스프링에서는 별도의 복잡한 설정 없이
	간편하게 AOP의 기능들을 구현할 수 있기 때문에 중요한 특징 중 하나이다.

AOP를 사용할 수 있을 때
	1. Around(모든 구역)
	2. Before(메소드 시작 직후)
	3. After(메소드 종료 직전)
		【리턴이 나오기 전이 아니라 리턴이 나오기 직전】

	4. AfterReturning(메소드 정상 종료 후)
		종료와 종료하기 전의 사이
		【After 이후 리턴 이전】
	5. AfterThrowing(메소드에서 예외 발생 종료 후)

@Aspect
	AOP라고 스프링에게 알려주는 것

AOP를 사용하기 위해서는 종단관심사에 Proxy설정이 되어야 한다.
	※ root-context.xml에 autoproxy
이는 root-context.xml에 auto로 설정을 해놓는다.
횡단관심사에서 작성한 모듈은 Proxy설정이 되어 있는 Target(주객체)에게
언제 결합해야 되는 지를 알려주어야 하는데, 이를 pointcut이라고 한다.
Target(주객체)에 있는 종단관심사가 호출되면 pointcut에 작성된 Target(메소드)
의 전체 정보를 가지고 올 수 있는 객체가 바로 JoinPoint(결합되는 지점)이다.

AOP 문법
	execution...은 AspectJ의 표현식이며, 맨 앞의 *은 접근제어자를 의미하고,
	맨 마지막의 *은 클래스의 이름과 메소드의 이름을 의미한다.
	..은 0개 이상이라는 의미이다.
	
	모든 접근 제어자(①*)의 SampleService이름이 붙은 모든 클래스(②*)에서 모든 메소드(③*) 중
	매개변수가 0개 이상(..)이라는 뜻.
	@Before("execution(①* com.koreait.service.SampleService②*.③*(..))"){ }

root-context.xml
	Namespaces에서 aop, context 체크

	<context:annotation-config></context:annotation-config>
		이렇게만 쓰면 【이미 등록된 Bean에 대해서만 Annotation을 활성화 한다.】
	
프록시
	【횡단관심사와 종단관심사를 연결시켜주는 역할】
	root-context.xml에서
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>만 추가하면 된다.


args(매개변수명, 매개변수명, ...)
호출된 종단관심사의 매개변수를 횡단관심사로 전달받을 때에는 매개변수의 개수와 타입에 맞게
작성해주어야 하며, args에 해당 매개변수의 이름을 동일하게 작성해주어야 한다.
doAdd라는 메소드 중 【매개변수를 (String, String)으로 받는 애가 들어왔을 때 
매개변수를 str1과 str2에 넣어줘(여기서 str1과 str2는 밑의 메소드의 매개변수의 이름)】
	@Before("execution(* com.koreait.service.SampleService*.doAdd【(String, String)) && args(str1, str2)")】
	public void logBeforeWithParam(String str1, String str2) { }

pointcut : 횡단관심사와 종단관심사의 결합되는 지점을 결정하는 것, 언제 연결해줄까라고 묻는 것
연결이 되고 나면 pointcut에 있는 매개변수가 타겟이 되는 것
예외를 처리할 때는 @AfterThrowing
pointcut만 쓸 경우 pointcut=는 생략이 가능하고 다른걸 사용할 경우 pointcut=를 명시해준다.
throwing에는 매개변수로 받는 예외의 객체를 넣는 것
	@AfterThrowing(pointcut="execution(* com.koreait.service.SampleService*.*(..))", throwing="exception")
	public void logException(Exception exception) {

메소드를 실행하면 이쪽으로 들어오는거라서 이쪽에서 메소드를 실행해줘야 한다.
ProceedingJoinPoint : Around를 했을 때 해당 메소드에 대한 모든 정보를 가지고 있는 애
	@Around("execution(* com.koreait.service.SampleService*.*(..))")
	public Object logTime(ProceedingJoinPoint pjp) {
		Long start = System.currentTimeMillis();
		
		log.info("핵심 로직 : "+pjp.getTarget());
		//Object[]로 리턴하기 때문에 Arrays.toString()을 사용
		log.info("파라미터 : "+Arrays.toString(pjp.getArgs()));
		
		Object result = null;
		
		try {
			//실행한 메소드의 리턴값 호출
			//얘를 안하면 메소드의 정보만 가져오고 실행을 안한 것
			result = pjp.proceed();
		} catch (Throwable e) {
			e.printStackTrace();
		}
		
		Long end = System.currentTimeMillis();
		log.info("걸린 시간 : " + (end-start));
		return result;
	}
---------------------------------------------------------------------------------------------------------
트랜잭션
	하나의 쿼리만 사용한다면 예외 발생 후 DB에는 변화가 없다.
	하지만 여러 개의 쿼리(하나의 트랜잭션)을 순차적으로 실행 후 문제 발생 시
	성공한 쿼리문만 반영되어 다시 직접 복구해야하는 문제가 발생한다.
	이러한 문제를 막기 위해 스프링에서는 【@Transactional을 사용하여
	한 개의 트랜잭션에 문제 발생 시 롤백을 통해 전체 트랜잭션이 모두
	DB에 반영되지 못하도록 막아준다.】
	@Transactional을 메소드 위에 쓴다.

	하나의 메소드에서 쿼리 여러 개가 순차적으로 진행되는 경우 사용한다.
	전혀 관계없는 쿼리끼리 있을 경우 사용할 필요가 없다.