글 등록 시 한글이 깨지는 경우
	web.xml에서
	<filter>
		<filter-name>encoding</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>   
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
   
	<filter-mapping>
		<filter-name>encoding</filter-name>
		<servlet-name>appServlet</servlet-name>
	</filter-mapping> 추가하기

목록보기, 글쓰기 버튼의 a태그 href에 /board/register 같은거 넣기

// 같은 내용을 2개 쓸 경우 새로 만드는게 아니라 경로만 추가하는 형식
	@GetMapping({"/get", "/modify"})

exception 추가
	web.xml
	root-context.xml
	src/main/java에 exception 패키지 추가
-------------------------------------------------------------------------------------------------------
화면 페이징 처리
	ORDER BY보다 인덱스를 사용하면 정렬을 생략할 수 있다.
	인덱스라는 존재가 이미 정렬된 구조이므로 이를 이용해서 별도의 정렬을 하지 않는다.
	예를 들어 데이터베이스 테이블을 하나의 책이라고 하면,
	인덱스는 각 페이지 번호를 의미한다.
	이를 통해서 원하는 내용을 위에서부터 혹은 반대로 찾아나가는 것을 스캔(scan)이라고 한다.

        
	{BNO	ROWID}	ROWID	BNO	TITLE	CONTENT
	1	AAAE8A	AAAE8A	1	...	...
	2	AAAE8B	AAAE8B	2	...	...
	3	AAAE8C	AAAE8E	1000	...	...
	4	AAAE8D	AAAE8C	3	...	...
	...	
	1000	AAAE8E	AAAE8D	4	...	...
	{} : 인덱스가 관리하는 부분 

	※ ROWID : 행 하나마다 부여되는 주소값

	힌트(Hint) : /*+ hint*/
		SELECT문에 실행하고 싶은 계획을 전달할 때 사용하는 문법.
		잘못 작성되어도 실행할 때에는 무시되며 별도의 오류는 발생하지 않는다.
		/*+로 시작하며 */로 마친다.
		또한 뒤에 컬럼명을 작성할 때 쉼표(,)를 사용하지 않는다.

		페이징 처리에서는 이미 정렬된 인덱스를 내림차순으로 가져오는 문법을 힌트 내에 작성해준다. 
		별도의 정렬이 필요 없어지므로 속도가 향상된다.

		<!-- 여기서 #{cri.amount}라고 안쓰는 이유는 매개변수로 어차피 객체가 하나밖에 안들어왔기 때문에 자동으로 매핑된다. -->
		<select id="getListWithPaging" resultType="com.koreait.domain.BoardVO">
			<![CDATA[
				SELECT BNO, TITLE, CONTENT, WRITER, REGDATE, UPDATEDATE
				FROM
								//테이블명 PK명(,는 생략)
					(SELECT /*+ INDEX_DESC(TBL_BOARD PK_BOARD) */ ← 이 부분이 Hint
						ROWNUM RN, BNO, TITLE, CONTENT, WRITER, REGDATE, UPDATEDATE
					FROM TBL_BOARD WHERE ROWNUM <= #{pageNum} * #{amount})
				WHERE RN > (#{pageNum} - 1) * #{amount}
			]]>
		</select>

		※ #{cri.amount}라고 안쓰는 이유는 매개변수로 어차피 객체가 하나밖에 안들어왔기 때문에 자동으로 매핑된다.

	※ Criteria : 검색의 기준

	※ Math.ceil() : 올림, 반올림 아님

	※ *을 사용하지 않는 이유는 컬럼을 직접 작성하는 것보다 훨씬 느리기 때문이다.★★	
	

