//댓글 시간
function displayTime(timeValue){
	var today = new Date();//현재 날짜
	var replyTime = new Date(timeValue);//작성 날짜
		
	var gap = today.getTime() - replyTime.getTime();
	
	//하루를 밀리초로 만들어서 비교
	if(gap < 24 * 60 * 60 * 1000){
		//오늘일 경우
		//시분초
		var hh = replyTime.getHours();
		var mm = replyTime.getMinutes();
		var ss = replyTime.getSeconds();
		
		return [(hh > 9 ? '' : '0') + hh, (mm > 9 ? '' : '0') + mm, (ss > 9 ? '' : '0') + ss].join(' : ');
	}else{
		//오늘이 아닐 경우
		//년월일
		var yy = replyTime.getFullYear();
		var mo = replyTime.getMonth() + 1;
		var dd = replyTime.getDate();
	
		return [yy, (mo > 9 ? '' : '0') + mo, (dd > 9 ? '' : '0') + dd].join(' - ');
	}
}
----------------------------------------------------------------------------------------------------------
encodeURIComponent()
	서버로 특정 문자열을 전송할 때 【명령어로 인식하는 문자 혹은 인식이 불가능한 문자를
	코드번호로 변경】시켜주는 함수

append()
	html()이 아니라 append()를 사용하는 이유는 
	【여러 번 첨부파일 추가를 진행했을 때 이전 목록을 유지하기 위함이다.】
----------------------------------------------------------------------------------------------------------
실시간 라이브러리
익스프레션 : 새로운 문법

pom.xml에 <!-- Thumbnailator --> 밑에 추가
	<!-- Quartz -->
		<dependency>
		<groupId>org.quartz-scheduler</groupId>
		<artifactId>quartz</artifactId>
		<version>2.3.0</version>
	</dependency>
   
	<dependency>
		<groupId>org.quartz-scheduler</groupId>
		<artifactId>quartz-jobs</artifactId>
		<version>2.3.0</version>
	</dependency>

root-context.xml에서 Namespaces에
	beans, context, mybatis, task, tx 체크

	<context:component-scan base-package="com.koreait.task"/>
	<task:annotation-driven/> 추가

public class FileCheckTask {
	
	@Setter(onMethod_ = @Autowired)
	private BoardAttachMapper attachMapper;
	
	// cron="0 * * * * *" : 매 분 0초마다 
	@Scheduled(cron="0 * * * * *")
	public void checkFiles() throws Exception {
		log.warn("-------------------------------");
		log.warn("file Check tast run............");
		log.warn("-------------------------------");
		
		List<BoardAttachVO> fileList = attachMapper.getOldFiles();
		
		//람다식으로 진행.
		//반복 시 저장된 데이터를 List 타입으로 변경할 때 사용된다.
		//stream().map() : map안에 있는 람다식을 통해 반복된 데이터를 Stream(순서가 있는)형태로 저장해 놓는다.
		List<Path> fileListPaths = fileList.stream().map(vo -> 
			//,를 쓰면 자동으로 연결이 되서 디렉토리 구분자를 쓸 필요가 없다.
			Paths.get("C:\\upload", vo.getUploadPath(), vo.getUuid() + "_" + vo.getFileName()))
				.collect(Collectors.toList()); //순서가 있는 Stream형태 객체는 collect메소드를 통하여 Collection Framework타입으로 변경시켜 사용이 가능하다.
		
		//이미지 파일을 filter로 검사 후 썸네일 경로도 fileListPaths에 저장
		//filter(조건식) : 조건을 걸어주는 것
		//filter는 해당 객체 안에 있는 boolean타입을 통하여 true일 때에만 뒤에 연결된 Stream으로 넘어가도록 해준다.
		//밑의 식에서 【filter가 false면 map으로 가지도 않는다.】
		fileList.stream().filter(vo -> vo.isFileType()).map(vo -> /* 이미지 파일 객체면 vo에 담는다. */ 
			Paths.get("C:\\upload", vo.getUploadPath(), "s_" + vo.getUuid() + "_" + vo.getFileName())) //원본 경로에 s_ 추가
		.forEach(p -> fileListPaths.add(p)); //어제 올린 첨부파일 중 이미지 파일들은 fileListPaths에 s_경로까지 추가해준다.
		
		fileListPaths.forEach(log::warn);
		
		//어제 업로드 폴더 경로
		//toFile() : Path를 File로 바꿔주는 것
		//get()은 ,를 쓰면 \를 하나씩 붙여준다.
		File targetDir = Paths.get("C:\\upload", getFolderYesterDay()).toFile();
		
		//listFiles(filter) : 필터에 걸러지지 않은 파일을 File[]로 가져오는 것
		//삭제할 파일들의 배열
		File[] removeFiles = targetDir.listFiles(file -> !fileListPaths.contains(file.toPath()));
		
		for (File file : removeFiles) {
			log.warn(file.getPath() + " deleted");
			file.delete();
		}
	}
	
	private String getFolderYesterDay() {
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		//싱글턴패턴
		Calendar cal = Calendar.getInstance();
		//일에서 -1을 하겠다. 
		cal.add(Calendar.DATE, -1);
		
		return sdf.format(cal.getTime()).replace("-", File.separator);
	}	
}
----------------------------------------------------------------------------------------------------------
안드로이드 스튜디오 설치
	안드로이드 스튜디오 검색 후 들어가서 최신버전 다운로드

	※ 【경로에 공백이나 한글이 있으면 안된다.★★★】

	Next > Next > C:\Android\Android Studio > install > Next > Finish
	> OK > Don't send > Next > Standard > Next > 색상 선택 > Next
	> Finish > Finish > Create new project > Empty Activity > Next
	> Name에 Test 입력 > Save location : Android\workspace\Test > 
	> Lanquage : Java > Minimum SDK : Oreo 8.1 > Finish

	우측 상단에 Pixel_3a_API_30_x86 선택하고
	Nexus 5X > Oreo 27 다운로드 > Accept > Finish

	※ 【안드로이드도 윈도우, 리눅스처럼 운영체제】
	※ Minimum SDK : 최소 여기까지는 이 어플을 다룰 수 있게 만들겠다.
	※ R : Resource
----------------------------------------------------------------------------------------------------------